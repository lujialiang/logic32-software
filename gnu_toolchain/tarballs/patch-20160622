diff -Naur gcc-3.4.2/config.sub ../gcc-3.4.2/config.sub
--- gcc-3.4.2/config.sub	2004-02-22 22:44:23.000000000 +0800
+++ ../gcc-3.4.2/config.sub	2019-06-22 17:29:49.000000000 +0800
@@ -271,6 +271,15 @@
 	| z8k)
 		basic_machine=$basic_machine-unknown
 		;;
+    zpu)
+        # Zylin ZPU
+        basic_machine=$basic_machine-unknown
+        os=-none
+        ;;
+    logic32)
+        basic_machine=$basic_machine-unknown
+        os=-none
+        ;;
 	m6811 | m68hc11 | m6812 | m68hc12)
 		# Motorola 68HC11/12.
 		basic_machine=$basic_machine-unknown
diff -Naur gcc-3.4.2/configure ../gcc-3.4.2/configure
--- gcc-3.4.2/configure	2004-06-26 05:33:15.000000000 +0800
+++ ../gcc-3.4.2/configure	2019-06-22 17:31:25.000000000 +0800
@@ -1339,6 +1339,12 @@
   m32r-*-*)
     noconfigdirs="$noconfigdirs ${libgcj}"
     ;;
+  zpu-*-*)
+    noconfigdirs="$noconfigdirs target-libiberty ${libgcj}"
+    ;;
+  logic32-*-*)
+    noconfigdirs="$noconfigdirs target-libiberty ${libgcj}"
+    ;;
   m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)
     noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj}"
     ;;
diff -Naur gcc-3.4.2/configure.in ../gcc-3.4.2/configure.in
--- gcc-3.4.2/configure.in	2004-06-26 05:33:14.000000000 +0800
+++ ../gcc-3.4.2/configure.in	2019-06-22 17:32:10.000000000 +0800
@@ -578,6 +578,12 @@
   m32r-*-*)
     noconfigdirs="$noconfigdirs ${libgcj}"
     ;;
+  zpu-*-*)
+    noconfigdirs="$noconfigdirs target-libiberty ${libgcj}"
+    ;;
+  logic32-*-*)
+    noconfigdirs="$noconfigdirs target-libiberty ${libgcj}"
+    ;;
   m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)
     noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj}"
     ;;
diff -Naur gcc-3.4.2/gcc/config/logic32/arit.c ../gcc-3.4.2/gcc/config/logic32/arit.c
--- gcc-3.4.2/gcc/config/logic32/arit.c	1970-01-01 08:00:00.000000000 +0800
+++ ../gcc-3.4.2/gcc/config/logic32/arit.c	2019-06-02 10:47:50.000000000 +0800
@@ -0,0 +1,32 @@
+typedef unsigned int USItype		__attribute__ ((mode (SI)));
+typedef unsigned int UDItype		__attribute__ ((mode (DI)));
+
+#if defined (L_mulsi3) 
+
+USItype
+__mulsi3 (USItype a, USItype b)
+{
+  USItype c = 0;
+
+  do 
+    {
+		/* use mask & unroll a bit */
+		c+=b&~(((a&1)-1));
+		a >>= 1;
+		b <<= 1;
+
+    } while (a != 0);
+
+  return c;
+}
+#endif
+
+#if defined (L_xordi3) 
+UDItype
+__xordi3 (UDItype a, UDItype b)
+{
+  return (a&~b)|(~a&b);
+}
+#endif
+
+
diff -Naur gcc-3.4.2/gcc/config/logic32/crti.asm ../gcc-3.4.2/gcc/config/logic32/crti.asm
--- gcc-3.4.2/gcc/config/logic32/crti.asm	1970-01-01 08:00:00.000000000 +0800
+++ ../gcc-3.4.2/gcc/config/logic32/crti.asm	2019-06-02 10:47:50.000000000 +0800
@@ -0,0 +1,8 @@
+	.section .init,"ax",@progbits
+	.globl	_init
+	.type	_init,@function
+_init:
+	.section .fini,"ax",@progbits
+	.globl	_fini
+	.type	_fini,@function
+_fini:
diff -Naur gcc-3.4.2/gcc/config/logic32/crtn.asm ../gcc-3.4.2/gcc/config/logic32/crtn.asm
--- gcc-3.4.2/gcc/config/logic32/crtn.asm	1970-01-01 08:00:00.000000000 +0800
+++ ../gcc-3.4.2/gcc/config/logic32/crtn.asm	2019-06-02 10:47:50.000000000 +0800
@@ -0,0 +1,6 @@
+
+	.section .init,"ax",@progbits
+	poppc
+
+	.section .fini,"ax",@progbits
+	poppc
diff -Naur gcc-3.4.2/gcc/config/logic32/logic32.c ../gcc-3.4.2/gcc/config/logic32/logic32.c
--- gcc-3.4.2/gcc/config/logic32/logic32.c	1970-01-01 08:00:00.000000000 +0800
+++ ../gcc-3.4.2/gcc/config/logic32/logic32.c	2019-06-11 09:10:43.000000000 +0800
@@ -0,0 +1,482 @@
+#include <stdio.h>
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "tree.h"
+#include "tm_p.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "recog.h"
+#include "expr.h"
+#include "libfuncs.h"
+#include "toplev.h"
+#include "basic-block.h"
+#include "function.h"
+#include "ggc.h"
+#include "reload.h"
+#include "target.h"
+#include "target-def.h"
+
+
+#define	RETURN_POINTER_REGNUM			31
+
+#if 0
+/* Save the operands last given to a compare for use when we
+   generate a scc or bcc insn.  */
+rtx logic32_compare_op0, logic32_compare_op1;
+#endif
+
+struct logic32_frame_info
+{
+	unsigned int total_size;	/* # Bytes that the entire frame takes up. */
+	unsigned int pretend_size;	/* # Bytes we push and pretend caller did. */
+	unsigned int args_size;		/* # Bytes that outgoing arguments take up. */
+	unsigned int reg_size;		/* # Bytes needed to store regs. */
+	unsigned int var_size;		/* # Bytes that variables take up. */
+	unsigned int frame_size;	/* # Bytes in current frame.  */
+	unsigned int gmask;			/* Mask of saved registers. */
+	unsigned int save_fp;		/* Nonzero if frame pointer must be saved. */
+	unsigned int save_rp;		/* Nonzero if return pointer must be saved. */
+	int          initialised;	/* Nonzero if frame size already calculated. */
+};
+
+/* Current frame information calculated by arc_compute_frame_size.  */
+static struct logic32_frame_info current_frame_info;
+
+const char *logic32_board_name = "logic32_v1";
+
+/* Tell prologue and epilogue if register REGNO should be saved / restored.
+   The return address and frame pointer are treated separately.
+   Don't consider them here.  */
+#define MUST_SAVE_REGISTER(regno)      \
+  (   (regno) != RETURN_POINTER_REGNUM \
+   && (regno) != FRAME_POINTER_REGNUM  \
+   &&   regs_ever_live [regno]         \
+   && ! call_used_regs [regno]         )
+
+#define MUST_SAVE_FRAME_POINTER	 (regs_ever_live [FRAME_POINTER_REGNUM]  || frame_pointer_needed)
+#define MUST_SAVE_RETURN_POINTER (regs_ever_live [RETURN_POINTER_REGNUM] || current_function_profile)
+
+#if UNITS_PER_WORD == 4
+#define WORD_ALIGN(SIZE) (((SIZE) + 3) & ~3)
+#endif
+
+/* Returns the number of bytes offset between FROM_REG and TO_REG
+   for the current function.  As a side effect it fills in the 
+   current_frame_info structure, if the data is available.  */
+static unsigned int logic32_compute_frame_size (int from_reg, int to_reg)
+{
+	int 		regno;
+	unsigned int 	return_value;
+	unsigned int	var_size;
+	unsigned int	args_size;
+	unsigned int	pretend_size;
+	unsigned int 	reg_size;
+	unsigned int 	gmask;
+
+	var_size	= WORD_ALIGN (get_frame_size ());
+	args_size	= WORD_ALIGN (current_function_outgoing_args_size);
+	pretend_size	= current_function_pretend_args_size;
+
+	reg_size	= 0;
+	gmask		= 0;
+
+	/* Calculate space needed for registers.  */
+	for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno ++)
+	{
+		if (MUST_SAVE_REGISTER (regno))
+		{
+			reg_size += UNITS_PER_WORD;
+			gmask |= 1 << regno;
+		}
+	}
+
+	current_frame_info.save_fp = MUST_SAVE_FRAME_POINTER;
+	current_frame_info.save_rp = MUST_SAVE_RETURN_POINTER;
+
+#if 0
+	reg_size += (current_frame_info.save_fp + current_frame_info.save_rp)
+	       * UNITS_PER_WORD;
+#else
+	reg_size += (current_frame_info.save_fp )
+	       * UNITS_PER_WORD;
+#endif
+
+	/* Save computed information.  */
+	current_frame_info.pretend_size = pretend_size;
+	current_frame_info.var_size     = var_size;
+	current_frame_info.args_size    = args_size;
+	current_frame_info.reg_size	  = reg_size;
+	current_frame_info.frame_size   = args_size + var_size;
+	current_frame_info.total_size   = args_size + var_size + reg_size + pretend_size;
+	current_frame_info.gmask	  = gmask;
+	current_frame_info.initialised  = reload_completed;
+
+	/* Calculate the required distance.  */
+	return_value = 0;
+
+	if (to_reg == STACK_POINTER_REGNUM)
+		return_value += args_size + var_size;
+
+	if (from_reg == ARG_POINTER_REGNUM)
+		return_value += reg_size;
+
+	return return_value;
+}
+
+/* Get the value of regs_ever_live[REGNO].  */
+static bool df_regs_ever_live_p (unsigned int regno)
+{
+  return regs_ever_live[regno];
+}
+
+
+void logic32_init_cumulative_args(CUMULATIVE_ARGS *cum, tree funtype, rtx libname, tree fndecl)
+{
+	memset(cum, 0, sizeof(*cum));
+	cum->nregs = MAX_LOGIC32_PARM_REGS;
+	cum->words = 0;
+	cum->regno = FIRST_ARG_REGNO;
+}
+
+void logic32_function_arg_advance(CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type, int named)
+{
+	HOST_WIDE_INT bytes, words;
+	if (mode == VOIDmode) bytes = int_size_in_bytes(type);
+	else bytes = GET_MODE_SIZE(mode);
+	words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
+
+	cum->words += words;
+	cum->nregs -= words;
+	cum->regno += words;
+
+	if (cum->nregs <= 0) {
+		cum->nregs = 0;
+		cum->regno = FIRST_ARG_REGNO;
+	}
+}
+
+rtx logic32_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode, tree type, int named)
+{
+	enum machine_mode mode = omode;
+	HOST_WIDE_INT bytes, words;
+
+	if (mode == BLKmode) bytes = int_size_in_bytes(type);
+	else bytes = GET_MODE_SIZE(mode);
+	words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
+
+	if ( words <= cum->nregs) {
+		int regno = cum->regno;
+		return gen_rtx_REG(mode, regno);
+	}
+
+	return NULL_RTX;
+}
+
+static int reg_save(int regno)
+{
+	int result=0;
+    if (regs_ever_live[regno]&&!call_used_regs[regno])
+	{
+		result=1;
+	}
+	/* FIX!!! how do we check if we've eliminated the argument pointer? */
+	return result;
+}
+
+static int calcSavedSize(void)
+{
+	int regno;
+	int savedSize=0;
+	for (regno = 0; regno < STACK_POINTER_REGNUM; regno++)
+		if (reg_save(regno))
+		{
+			savedSize+=4;
+		}
+	return savedSize;	 
+}
+
+static int calcStackRegSize(void)
+{
+	int regno;
+	int savedSize=0;
+	for (regno = STACK_POINTER_REGNUM; regno < FIRST_PSEUDO_REGISTER; regno++)
+		if (reg_save(regno))
+		{
+			savedSize+=4;
+		}
+	return savedSize;	 
+}
+
+/* Define the offset between two registers, one to be eliminated, and the
+   other its replacement, at the start of a routine.  */
+int logic32_initial_elimination_offset (int from, int to)
+{
+	int offset;
+	/* The difference between the argument pointer and the stack pointer is
+	 * the sum of the size of this function's frame, the callee register save
+	 * area, and the fixed stack space needed for function calls (if any). 
+	 */
+	if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)
+	{
+    	offset=current_function_outgoing_args_size + calcStackRegSize() + get_frame_size () + calcSavedSize() + 4 ;
+	} else if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)
+    {
+    	offset=calcSavedSize() + 4;
+    } else if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)
+	{
+		offset=current_function_outgoing_args_size + calcStackRegSize() + get_frame_size ();
+	} else if (from == FRAME_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)
+	{
+		offset=0;
+	} else
+	{
+		abort ();
+	}
+    return offset;
+}
+
+int logic32_legitimate_address(enum machine_mode mode, rtx addr_x, int strict_p)
+{
+	struct logic32_address_info addr;
+	logic32_classify_address(&addr, mode, addr_x, strict_p);
+}
+
+bool logic32_classify_address(struct logic32_address_info *addr_info, enum machine_mode mode, rtx addr_x, bool strict_p)
+{
+	switch (GET_CODE(addr_x))
+	{
+		case REG:
+		case SUBREG:
+			addr_info->type = ADDRESS_REG;
+			addr_info->reg = addr_x;
+			addr_info->offset = const0_rtx;
+			return true;
+
+		case PLUS:
+			addr_info->type = BASE_ADDRESS_REG;
+			addr_info->reg = XEXP(addr_x, 0);
+			addr_info->offset = XEXP(addr_x, 1);
+			addr_info->base_rtx = addr_info->reg;
+			return (REG_P(addr_info->reg) && logic32_regno_mode_ok_for_base_p(REGNO(addr_info->reg), mode, strict_p));
+
+		case CONST_INT:
+			addr_info->type = ADDRESS_CONST_INT;
+			return true;
+
+		case CONST:
+		case LABEL_REF:
+		case SYMBOL_REF:
+			addr_info->type = ADDRESS_SYMBOLIC;
+			return true;
+
+		default:
+#if 0
+			if ( MEM == GET_CODE(addr_x) ) {
+				printf("#### MEM ?????\n");
+			} 
+			printf("\t CODE IS: <<ERROR!!!>> ENUM code is : %d\n", GET_CODE(addr_x));
+#endif
+			return false;
+	}
+}
+
+bool logic32_regno_mode_ok_for_base_p(int regno, enum machine_mode mode, bool strict_p)
+{
+	(void)mode;
+	if (!HARD_REGISTER_NUM_P(regno))
+	{
+		if (!strict_p) return true;
+		regno = reg_renumber[regno];
+	}
+	if (regno == ARG_POINTER_REGNUM || regno == FRAME_POINTER_REGNUM || regno == STACK_POINTER_REGNUM ) {
+		return true;
+	}
+	return GP_REG_P(regno);
+}
+
+void logic32_print_operand (FILE *file, rtx op, int letter)
+{
+	enum rtx_code code;
+	/*gcc_assert(op);*/
+	code = GET_CODE(op);
+	switch(code)
+	{
+		case REG: fprintf(file, "%s", reg_names[REGNO(op)]); break;
+		case MEM: output_address(XEXP(op, 0)); break;
+		case CONST_INT: output_addr_const(file, op); break;
+		case LABEL_REF: output_addr_const(file, op); break;
+		default: printf("\n ###### @ %s:%d #######\n", __FILE__, __LINE__);	break;
+	}
+}
+
+void logic32_print_operand_address(FILE *file, rtx x)
+{
+	struct logic32_address_info addr;
+	/*int value, tst_value;*/
+
+	if (!logic32_classify_address(&addr, word_mode, x, true)) {
+		printf("bad operand address\n");
+		return;
+	}
+
+	switch(addr.type)
+	{
+		case ADDRESS_REG:
+			logic32_print_operand(file, addr.reg, 0);
+			return;
+		case BASE_ADDRESS_REG:
+			logic32_print_operand(file, addr.offset, 0);
+			fprintf(file, "(");
+			logic32_print_operand(file, addr.base_rtx, 0);
+			fprintf(file, ")");
+			return;
+		case ADDRESS_CONST_INT:
+			fprintf(file, "(");
+			output_addr_const(file, x);
+			fprintf(file, ")");
+			return;
+		case ADDRESS_SYMBOLIC:
+			/*output_addr_const(file, logic32_strip_unspec_address(x));*/
+			output_addr_const (file, x);
+			return;
+	}
+	fprintf(stderr, "fatal error, unreachable here. file:%s, line:%d\n", __FILE__, __LINE__);
+	/*gcc_unreachable();*/
+}
+
+void logic32_expand_prologue(void)
+{
+	int regno;
+	rtx insn;
+	rtx sp_rtx;
+	rtx fp_rtx;
+	int sp_offset;
+
+	if (reload_completed != 1)
+		abort ();
+
+	sp_rtx = gen_rtx_REG(Pmode, STACK_POINTER_REGNUM);
+	fp_rtx = gen_rtx_REG (Pmode, HARD_FRAME_POINTER_REGNUM);
+
+	logic32_compute_frame_size(0, 0);
+
+	/* Save callee-saved registers.  */
+	sp_offset = 0;
+	for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno ++)
+	{
+		if (MUST_SAVE_REGISTER (regno))
+		{
+			sp_offset = sp_offset - 4;
+			insn = emit_insn (gen_store_reg(GEN_INT(sp_offset), gen_rtx_REG (Pmode, regno)));
+			RTX_FRAME_RELATED_P (insn) = 1;
+		}
+	}
+
+	if ( current_frame_info.save_fp ) {
+		/* store $bp */
+		sp_offset -= 4;
+		insn = emit_insn (gen_store_reg (GEN_INT(sp_offset), fp_rtx));
+		RTX_FRAME_RELATED_P (insn) = 1;
+	}
+
+	if ( sp_offset ) {
+		/* add $sp, $sp, #sp_offset */
+		insn = emit_insn (gen_addsi3(sp_rtx, sp_rtx, GEN_INT(sp_offset)));
+		RTX_FRAME_RELATED_P (insn) = 1;
+	}
+
+	if ( current_frame_info.save_fp ) {
+		/* mov $fp, $sp */
+		insn = emit_insn (gen_movsi(fp_rtx, sp_rtx));
+		RTX_FRAME_RELATED_P (insn) = 1;
+	}
+
+	if (current_frame_info.frame_size ) {
+		/* add $sp, $sp, #sp_offset */
+		insn = emit_insn (gen_addsi3(sp_rtx, sp_rtx, GEN_INT(-(int)(current_frame_info.frame_size))));
+		RTX_FRAME_RELATED_P (insn) = 1;
+	}
+}
+
+void logic32_expand_epilogue (void)
+{
+	int frameSize;
+	int regno;
+	rtx insn;
+	rtx sp_rtx;
+	rtx fp_rtx;
+	int sp_offset;
+
+	if (reload_completed != 1)
+		abort ();
+
+/*
+	frameSize = logic32_compute_frame_size(0, 0);
+*/
+
+	printf("\n#################################################\n");
+	printf("total size: %d\n", current_frame_info.total_size);
+	printf("pretend size: %d\n", current_frame_info.pretend_size);
+	printf("args size: %d\n", current_frame_info.args_size);
+	printf("reg size: %d\n", current_frame_info.reg_size);
+	printf("var size: %d\n", current_frame_info.var_size);
+	printf("frame size: %d\n", current_frame_info.frame_size);
+	printf("save fp: %d\n", current_frame_info.save_fp);
+	printf("save rp: %d\n", current_frame_info.save_rp);
+	printf("#################################################\n");
+
+	sp_rtx = gen_rtx_REG(Pmode, STACK_POINTER_REGNUM);
+	fp_rtx = gen_rtx_REG (Pmode, HARD_FRAME_POINTER_REGNUM);
+
+	if ( current_frame_info.save_fp ) {
+		/* mov $sp, $fp */
+		insn = emit_insn (gen_movsi(sp_rtx, fp_rtx));
+		RTX_FRAME_RELATED_P (insn) = 1;
+	}
+
+	if ( current_frame_info.reg_size ) {
+		/* add $sp, $sp, #regsize */
+		insn = emit_insn (gen_addsi3(sp_rtx, sp_rtx, GEN_INT((current_frame_info.reg_size))));
+		RTX_FRAME_RELATED_P (insn) = 1;
+	}
+
+	sp_offset = 0;
+
+	if ( current_frame_info.save_fp ) {
+		/* load $fp */
+		sp_offset -= 4;
+		insn = emit_insn (gen_load_reg (fp_rtx, GEN_INT(sp_offset)));
+		RTX_FRAME_RELATED_P (insn) = 1;
+	}
+
+	/* Restore callee-saved registers.  */
+	for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno ++)
+	{
+		if (MUST_SAVE_REGISTER (regno))
+		{
+			sp_offset -= 4;
+			insn = emit_insn (gen_load_reg(gen_rtx_REG (Pmode, regno), GEN_INT(sp_offset)));
+			RTX_FRAME_RELATED_P (insn) = 1;
+		}
+	}
+
+	emit_jump_insn (gen_return());
+}
+
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+
+/*
+#include "gt-logic32.h"
+*/
+
diff -Naur gcc-3.4.2/gcc/config/logic32/logic32.h ../gcc-3.4.2/gcc/config/logic32/logic32.h
--- gcc-3.4.2/gcc/config/logic32/logic32.h	1970-01-01 08:00:00.000000000 +0800
+++ ../gcc-3.4.2/gcc/config/logic32/logic32.h	2019-06-11 09:15:02.000000000 +0800
@@ -0,0 +1,1189 @@
+/* Definitions of target machine for GNU compiler.
+   logic32.
+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2019
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.
+
+Note:
+
+*/
+
+/*****************************************************************************
+**
+** Controlling the Compilation Driver, `gcc'
+**
+*****************************************************************************/
+
+#undef ENDFILE_SPEC
+
+/* Compile and assemble for a 68hc11 unless there is a -m68hc12 option.  */
+/*
+#ifndef ASM_SPEC
+#define ASM_SPEC                                                \
+#endif
+*/
+
+/* Some machines may desire to change what optimizations are
+   performed for various optimization levels.   This macro, if
+   defined, is executed once just after the optimization level is
+   determined and before the remainder of the command options have
+   been parsed.  Values set in this macro are used as the default
+   values for the other command line options.
+
+   LEVEL is the optimization level specified; 2 if -O2 is
+   specified, 1 if -O is specified, and 0 if neither is specified.  */
+
+#define OPTIMIZATION_OPTIONS(LEVEL,SIZE)				\
+{									\
+  if (LEVEL >= 2)							\
+    {									\
+        flag_inline_functions		= 1;				\
+      flag_omit_frame_pointer		= 1;				\
+    }									\
+}
+
+/* We need to tell the linker the target elf format.  Just pass an
+   emulation option.  This can be overridden by -Wl option of gcc.  */
+/*
+#ifndef LINK_SPEC
+#define LINK_SPEC                                               \
+#endif
+*/
+
+#ifndef LIB_SPEC
+#define LIB_SPEC       ""
+#endif
+
+#ifndef CC1_SPEC
+#define CC1_SPEC       ""
+#endif
+
+#ifndef CPP_SPEC
+#define CPP_SPEC      ""
+#endif
+
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "crt1%O%s"
+
+#define MOVE_MAX  UNITS_PER_WORD
+
+/* Names to predefine in the preprocessor for this target machine.  */
+#define TARGET_CPU_CPP_BUILTINS()		\
+  do						\
+    {						\
+      builtin_define_std ("__logic32__");		\
+    }						\
+  while (0)
+
+/* As an embedded target, we have no libc.  */
+#ifndef inhibit_libc
+#  define inhibit_libc
+#endif
+
+#if 0
+/* Forward type declaration for prototypes definitions.
+   rtx_ptr is equivalent to rtx. Can't use the same name.  */
+struct rtx_def;
+typedef struct rtx_def *rtx_ptr;
+
+union tree_node;
+typedef union tree_node *tree_ptr;
+
+/* We can't declare enum machine_mode forward nor include 'machmode.h' here.
+   Prototypes defined here will use an int instead. It's better than no
+   prototype at all.  */
+typedef int enum_machine_mode;
+#endif
+
+/*****************************************************************************
+**
+** Run-time Target Specification
+**
+*****************************************************************************/
+
+/* Run-time compilation parameters selecting different hardware subsets.  */
+
+extern int target_flags;
+
+extern short *reg_renumber;	/* def in local_alloc.c */
+
+/* Macros used in the machine description to test the flags.  */
+
+/* Default target_flags if no switches specified.  */
+#ifndef TARGET_DEFAULT
+# define TARGET_DEFAULT			(1)
+#endif
+
+/* Define this macro as a C expression for the initializer of an
+   array of string to tell the driver program which options are
+   defaults for this target and thus do not need to be handled
+   specially when using `MULTILIB_OPTIONS'.  */
+#ifndef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS { "meb" }
+#endif
+
+
+/* Macro to define tables used to set the flags. This is a list in braces of
+   pairs in braces, each pair being { "NAME", VALUE } where VALUE is the bits
+   to set or minus the bits to clear. An empty string NAME is used to
+   identify the default VALUE.  */
+#define TARGET_SWITCHES						\
+  {{ "", TARGET_DEFAULT, 0 }}
+
+/* This macro is similar to `TARGET_SWITCHES' but defines names of
+   command options that have values.  Its definition is an
+   initializer with a subgrouping for each command option.
+
+   Each subgrouping contains a string constant, that defines the
+   fixed part of the option name, and the address of a variable.  The
+   variable, type `char *', is set to the variable part of the given
+   option if the fixed part matches.  The actual option name is made
+   by appending `-m' to the specified name.  */
+#if 0
+extern const char *logic32_board_name;
+#define TARGET_OPTIONS {						      \
+ { "board=", &logic32_board_name, N_("Specify the LOGIC32 board name"), 0} }
+#endif
+
+/* These are meant to be redefined in the host dependent files */
+#if 0
+#define SUBTARGET_SWITCHES
+#define SUBTARGET_OPTIONS
+#endif
+
+/* Print subsidiary information on the compiler version in use.  */
+#define TARGET_VERSION	fprintf (stderr, " (LOGIC32-ISA2)")
+
+/* Sometimes certain combinations of command options do not make
+   sense on a particular target machine.  You can define a macro
+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if
+   defined, is executed once just after all the command options have
+   been parsed.
+
+   Don't use this macro to turn on various extra optimizations for
+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */
+#if 0
+#define OVERRIDE_OPTIONS	logic32_override_options ();
+#endif
+
+/* target machine storage layout */
+
+/* Define this if most significant byte of a word is the lowest numbered.  */
+#define BYTES_BIG_ENDIAN 	0
+
+/* Define this if most significant bit is lowest numbered
+   in instructions that operate on numbered bit-fields.  */
+#define BITS_BIG_ENDIAN		0
+
+/* Define this if most significant word of a multiword number is numbered.  */
+#define WORDS_BIG_ENDIAN 	0
+
+/* Width of a word, in units (bytes).  */
+#define UNITS_PER_WORD		4
+
+/* Definition of size_t. */
+#define SIZE_TYPE               "unsigned int"
+
+/* A C expression for a string describing the name of the data type
+   to use for the result of subtracting two pointers.  The typedef
+   name `ptrdiff_t' is defined using the contents of the string. */
+#define PTRDIFF_TYPE            "unsigned int"
+
+/* Allocation boundary (bits) for storing pointers in memory.  */
+#define POINTER_BOUNDARY	32
+
+/* Normal alignment required for function parameters on the stack, in bits.
+   This can't be less than BITS_PER_WORD */
+#define PARM_BOUNDARY		32
+
+/* Boundary (bits) on which stack pointer should be aligned.  */
+#define STACK_BOUNDARY		32
+
+/* Allocation boundary (bits) for the code of a function.  */
+#define FUNCTION_BOUNDARY	32
+
+/* No data type wants to be aligned rounder than this.  */
+#define BIGGEST_ALIGNMENT	32
+
+/* Alignment of field after `int : 0' in a structure.  */
+#define EMPTY_FIELD_BOUNDARY	32
+
+/* Every structure's size must be a multiple of this.  */
+#define STRUCTURE_SIZE_BOUNDARY 32
+
+/* Define this if instructions will fail to work if given data not
+   on the nominal alignment.  If instructions will merely go slower
+   in that case, do not define this macro.  */
+/* All accesses must be aligned.  */
+#define STRICT_ALIGNMENT	1
+
+/* An integer expression for the size in bits of the largest integer
+   machine mode that should actually be used.  All integer machine modes of
+   this size or smaller can be used for structures and unions with the
+   appropriate sizes.  */
+#define MAX_FIXED_MODE_SIZE	64
+
+/* target machine storage layout */
+
+/* Size (bits) of the type "int" on target machine
+   (If undefined, default is BITS_PER_WORD).  */
+#define INT_TYPE_SIZE			32
+
+/* Size (bits) of the type "short" on target machine */
+#define SHORT_TYPE_SIZE			16
+
+/* Size (bits) of the type "long" on target machine */
+#define LONG_TYPE_SIZE			32
+
+/* Size (bits) of the type "long long" on target machine */
+#define LONG_LONG_TYPE_SIZE     64
+
+/* A C expression for the size in bits of the type `float' on the
+   target machine. If you don't define this, the default is one word.
+   Don't use default: a word is only 16.  */
+#define FLOAT_TYPE_SIZE         32
+
+/* A C expression for the size in bits of the type double on the target
+   machine. If you don't define this, the default is two words.
+   Be IEEE compliant.  */
+#define DOUBLE_TYPE_SIZE        64
+
+#define LONG_DOUBLE_TYPE_SIZE   64
+
+/* Define this as 1 if `char' should by default be signed; else as 0.  */
+#define DEFAULT_SIGNED_CHAR	0
+
+/* Define these to avoid dependence on meaning of `int'. */
+#define WCHAR_TYPE              "int"
+#define WCHAR_TYPE_SIZE         32
+
+
+/* Standard register usage.  */
+
+/* Number of actual hardware registers. The hardware registers are assigned
+   numbers for the compiler from 0 to just below FIRST_PSEUDO_REGISTER. 
+   All registers that the compiler knows about must be given numbers, even
+   those that are not normally considered general registers.  */
+#define FIRST_PSEUDO_REGISTER     32
+
+/* 1 for registers that have pervasive standard uses and are not available
+   for the register allocator.  */
+#define FIXED_REGISTERS \
+  /*0,1,2,3,4,5,6,7                                         k1,k2,gp,sp,fp,ra*/ \
+  { 1,1,1,1,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,1,1,1,1,1,1}
+
+
+/* 1 for registers not available across function calls. For our pseudo
+   registers, all are available.  */
+#define CALL_USED_REGISTERS \
+  { 1,1,1,1,1,1,1,1,	\
+	0,0,0,0,0,0,0,0,	\
+	1,1,1,1,1,1,1,1,	\
+	0,0,1,1,1,1,1,1}
+
+
+/* How to refer to registers in assembler output.  This sequence is indexed
+   by compiler's hard-register-number (see above).  */
+#define REGISTER_NAMES \
+  { "$zero","$at","$v0","$v1","$a0","$a1","$a2","$a3", \
+  	"$t0","$t1","$t2","$t3","$t4","$t5","$t6","$t7", \
+  	"$s0","$s1","$s2","$s3","$s4","$s5","$s6","$s7", \
+  	"$t8","$t9","$k0","$k1","$gp","$sp","$fp","$ra", \
+  	}
+
+
+/* Define this macro to change register usage conditional on target flags.
+
+   The soft-registers are disabled or enabled according to the
+  -msoft-reg-count=<n> option.  */
+
+#if 0
+#define CONDITIONAL_REGISTER_USAGE (m68hc11_conditional_register_usage ())
+#endif
+
+/* List the order in which to allocate registers.  Each register must be
+   listed once, even those in FIXED_REGISTERS.  */
+#define REG_ALLOC_ORDER {\
+	0,1,2,3,4,5,6,7, \
+	8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31, \
+	}
+
+
+/* A C expression for the number of consecutive hard registers,
+   starting at register number REGNO, required to hold a value of
+   mode MODE.  */
+#define HARD_REGNO_NREGS(REGNO, MODE) ((GET_MODE_SIZE(MODE) + UNITS_PER_WORD -1)/UNITS_PER_WORD)
+
+/* we only allow >32 bits in non-memory mapped registers */
+#define HARD_REGNO_MODE_OK(REGNO, MODE) ((GET_MODE_SIZE(MODE)<=UNITS_PER_WORD))
+
+/* Value is 1 if it is a good idea to tie two pseudo registers when one has
+   mode MODE1 and one has mode MODE2.  If HARD_REGNO_MODE_OK could produce
+   different values for MODE1 and MODE2, for any hard reg, then this must be
+   0 for correct output.
+
+   All modes are tieable except QImode.  */
+#define MODES_TIEABLE_P(MODE1, MODE2) 1
+
+
+/* Define this macro if the compiler should avoid copies to/from CCmode
+   registers.  You should only define this macro if support fo copying to/from
+   CCmode is incomplete.  */
+#define AVOID_CCMODE_COPIES
+
+
+/* Define the classes of registers for register constraints in the
+   machine description.  Also define ranges of constants.
+
+   One of the classes must always be named ALL_REGS and include all hard regs.
+   If there is more than one class, another class must be named NO_REGS
+   and contain no registers.
+
+   The name GENERAL_REGS must be the name of a class (or an alias for
+   another name such as ALL_REGS).  This is the class of registers
+   that is allowed by "g" or "r" in a register constraint.
+   Also, registers outside this class are allocated only when
+   instructions express preferences for them.
+
+   The classes must be numbered in nondecreasing order; that is,
+   a larger-numbered class must never be contained completely
+   in a smaller-numbered class.
+
+   For any two classes, it is very desirable that there be another
+   class that represents their union.  */
+
+enum reg_class
+{
+    NO_REGS,
+    GENERAL_REGS,
+    ALL_REGS,
+    LIM_REG_CLASSES
+};
+
+#define N_REG_CLASSES	(int) LIM_REG_CLASSES
+
+/* Give names of register classes as strings for dump file.  */
+#define REG_CLASS_NAMES \
+  { "NO_REGS",                                          \
+    "GENERAL_REGS",                                     \
+    "ALL_REGS" }
+
+
+/* An initializer containing the contents of the register classes,
+   as integers which are bit masks.  The Nth integer specifies the
+   contents of class N.  The way the integer MASK is interpreted is
+   that register R is in the class if `MASK & (1 << R)' is 1.  */
+
+/*
+#define REG_CLASS_CONTENTS \
+  {\
+  	{0},              \
+    {0x00ffffff}, \
+    {0xffffffff}, }
+*/
+#define REG_CLASS_CONTENTS \
+  {\
+  	{0},              \
+    {0xffffffff}, \
+    {0xffffffff}, }
+
+#define GP_REG_P(REGNO) ((REGNO)<FIRST_PSEUDO_REGISTER)
+
+/* set up a C expression whose value is a register class containing hard
+   register REGNO */
+#define REGNO_REG_CLASS(REGNO) (((REGNO)<FIRST_PSEUDO_REGISTER)?GENERAL_REGS:ALL_REGS)
+
+/* The class value for base registers. */
+#define BASE_REG_CLASS GENERAL_REGS
+
+/* The class value for index registers. */
+#define INDEX_REG_CLASS GENERAL_REGS
+
+/* A C expression which defines the machine-dependent operand constraint
+   letters for register classes.  If CHAR is such a letter, the value should be
+   the register class corresponding to it.  Otherwise, the value should be
+   `NO_REGS'.  The register letter `r', corresponding to class `GENERAL_REGS',
+   will not be passed to this macro; you do not need to handle it.
+
+   The following letters are unavailable, due to being used as
+   constraints:
+	'0'..'9'
+	'<', '>'
+	'E', 'F', 'G', 'H'
+	'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P'
+	'Q', 'R', 'S', 'T', 'U'
+	'V', 'X'
+	'g', 'i', 'm', 'n', 'o', 'p', 'r', 's' */
+
+/* Get reg_class from a letter in the machine description.  */
+#define REG_CLASS_FROM_LETTER(C) NO_REGS
+
+/* Given an rtx X being reloaded into a reg required to be
+   in class CLASS, return the class of reg to actually use.
+   In general this is just CLASS; but on some machines
+   in some cases it is preferable to use a more restrictive class.  
+*/
+#define PREFERRED_RELOAD_CLASS(X,CLASS) GENERAL_REGS
+
+/* #define SMALL_REGISTER_CLASSES 0 */
+
+/* A C expression that is nonzero if hard register number REGNO2 can be
+   considered for use as a rename register for REGNO1 */
+#if 0
+#define HARD_REGNO_RENAME_OK(REGNO1,REGNO2) \
+  logic32_hard_regno_rename_ok ((REGNO1), (REGNO2))
+#endif
+
+/* A C expression whose value is nonzero if pseudos that have been
+   assigned to registers of class CLASS would likely be spilled
+   because registers of CLASS are needed for spill registers.
+
+   The default value of this macro returns 1 if CLASS has exactly one
+   register and zero otherwise.  On most machines, this default
+   should be used.  Only define this macro to some other expression
+   if pseudo allocated by `local-alloc.c' end up in memory because
+   their hard registers were needed for spill registers.  If this
+   macro returns nonzero for those classes, those pseudos will only
+   be allocated by `global.c', which knows how to reallocate the
+   pseudo to another register.  If there would not be another
+   register available for reallocation, you should not change the
+   definition of this macro since the only effect of such a
+   definition would be to slow down register allocation.  */
+/* #define CLASS_LIKELY_SPILLED_P(class)  1 */
+
+/* Return the maximum number of consecutive registers needed to represent
+   mode MODE in a register of class CLASS.  */
+#define CLASS_MAX_NREGS(CLASS, MODE) HARD_REGNO_NREGS(CLASS, MODE)
+
+/* A C expression that defines the machine-dependent operand constraint letters
+   (`I', `J', `K', .. 'P') that specify particular ranges of integer values.
+   If C is one of those letters, the expression should check that VALUE, an
+   integer, is in the appropriate range and return 1 if so, 0 otherwise.  If C
+   is not one of those letters, the value should be 0 regardless of VALUE.  */
+#define CONST_OK_FOR_LETTER_P(VALUE, C) 0
+
+/* Similar, but for floating constants, and defining letters G and H.
+
+   `G' is for 0.0.  */
+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \
+  ((C) == 'G' ? (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT \
+		 && VALUE == CONST0_RTX (GET_MODE (VALUE))) : 0) 
+
+/* 'U' represents certain kind of memory indexed operand for 68HC12.
+   and any memory operand for 68HC11.
+   'R' represents indexed addressing mode or access to page0 for 68HC11.
+   For 68HC12, it represents any memory operand.  */
+
+/* Stack layout; function entry, exit and calling.  */
+
+/* Define this if pushing a word on the stack
+   makes the stack pointer a smaller address.  */
+#define STACK_GROWS_DOWNWARD
+
+/* Define this if the nominal address of the stack frame
+   is at the high-address end of the local variables;
+   that is, each additional local variable allocated
+   goes at a more negative offset in the frame.
+
+   Don't define for 68HC11, the frame pointer is the bottom
+   of local variables.  */
+#define FRAME_GROWS_DOWNWARD
+
+/* Define this if successive arguments to a function occupy decreasing 
+   addresses in the stack.  */
+/* #define ARGS_GROW_DOWNWARD */
+
+/* Offset within stack frame to start allocating local variables at.
+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the
+   first local allocated.  Otherwise, it is the offset to the BEGINNING
+   of the first local allocated.  */
+#define STARTING_FRAME_OFFSET		0
+
+/* Offset of first parameter from the argument pointer register value.  */
+
+#define FIRST_PARM_OFFSET(FNDECL)	2
+
+/* After the prologue, RA is at 0(AP) in the current frame.  */
+#define RETURN_ADDR_RTX(COUNT, FRAME)					\
+  ((COUNT) == 0								\
+   ? gen_rtx_MEM (Pmode, arg_pointer_rtx)                               \
+   : 0)
+
+/* Before the prologue, the top of the frame is at 4(sp).  */
+#define INCOMING_FRAME_SP_OFFSET        4
+
+/* Define this if functions should assume that stack space has been
+   allocated for arguments even when their values are passed in
+   registers.
+  
+   The value of this macro is the size, in bytes, of the area reserved for
+   arguments passed in registers.
+  
+   This space can either be allocated by the caller or be a part of the
+   machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE'
+   says which.  */
+/* #define REG_PARM_STACK_SPACE(FNDECL)	2 */
+
+/* Define this macro if REG_PARM_STACK_SPACE is defined but stack
+   parameters don't skip the area specified by REG_PARM_STACK_SPACE.
+   Normally, when a parameter is not passed in registers, it is placed on
+   the stack beyond the REG_PARM_STACK_SPACE area.  Defining this macro  
+   suppresses this behavior and causes the parameter to be passed on the
+   stack in its natural location.  */
+/* #define STACK_PARMS_IN_REG_PARM_AREA */
+
+/* Register to use for pushing function arguments.  */
+#define STACK_POINTER_REGNUM		29
+
+/* Base register for access to local variables of the function.  */
+#define FRAME_POINTER_REGNUM		30
+
+/* Base register for access to arguments of the function.  */
+#define ARG_POINTER_REGNUM			27	/* fake */
+
+/* Register in which static-chain is passed to a function.  */
+#if 0
+#define STATIC_CHAIN_REGNUM	        SOFT_Z_REGNUM
+#endif
+
+/* A C expression which is nonzero if a function must have and use a frame
+   pointer.  This expression is evaluated in the reload pass.  If its value is
+   nonzero the function will have a frame pointer.
+
+   The expression can in principle examine the current function and decide
+   according to the facts, but on most machines the constant 0 or the constant
+   1 suffices.  Use 0 when the machine allows code to be generated with no
+   frame pointer, and doing so saves some time or space.  Use 1 when there is
+   no possible advantage to avoiding a frame pointer.
+
+   In certain cases, the compiler does not know how to produce valid code
+   without a frame pointer.  The compiler recognizes those cases and
+   automatically gives the function a frame pointer regardless of what
+   `FRAME_POINTER_REQUIRED' says.  You don't need to worry about them.
+
+   In a function that does not require a frame pointer, the frame pointer
+   register can be allocated for ordinary usage, unless you mark it as a fixed
+   register.  See `FIXED_REGISTERS' for more information.  */
+/* #define FRAME_POINTER_REQUIRED 0 */
+#define FRAME_POINTER_REQUIRED \
+     (flag_omit_frame_pointer == 0 || current_function_pretend_args_size > 0)
+
+/* Definitions for register eliminations.
+
+   This is an array of structures.  Each structure initializes one pair
+   of eliminable registers.  The "from" register number is given first,
+   followed by "to".  Eliminations of the same "from" register are listed
+   in order of preference.
+
+   We have two registers that are eliminated on the logic32. The pseudo arg
+   pointer and pseudo frame pointer registers can always be eliminated;
+   they are replaced with either the stack or the real frame pointer.  */
+
+#define ELIMINABLE_REGS				\
+{						\
+  {ARG_POINTER_REGNUM,	 STACK_POINTER_REGNUM},	\
+  {ARG_POINTER_REGNUM,	 FRAME_POINTER_REGNUM},	\
+  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}	\
+}
+
+/* Given FROM and TO register numbers, say whether this elimination is allowed.
+   Frame pointer elimination is automatically handled.
+
+   All other eliminations are valid.  */
+#define CAN_ELIMINATE(FROM, TO)						\
+ ((TO) == FRAME_POINTER_REGNUM || ! frame_pointer_needed)
+
+
+
+/* Define the offset between two registers, one to be eliminated, and the other
+   its replacement, at the start of a routine.  */
+#define INITIAL_ELIMINATION_OFFSET(from_reg,to_reg,offset) {offset=logic32_initial_elimination_offset(from_reg, to_reg);}
+
+/* Passing Function Arguments on the Stack.  */
+
+/* When a prototype says `char' or `short', really pass an `int'.  */
+/* #define PROMOTE_PROTOTYPES */
+
+/* If we generate an insn to push BYTES bytes, this says how many the
+   stack pointer really advances by. No rounding or alignment needed
+   for MC6811.  */
+#define PUSH_ROUNDING(BYTES)	(BYTES)
+
+/* Value is 1 if returning from a function call automatically pops the
+   arguments described by the number-of-args field in the call. FUNTYPE is
+   the data type of the function (as a tree), or for a library call it is
+   an identifier node for the subroutine name.
+  
+   The standard logic32 call, with arg count word, includes popping the
+   args as part of the call template.  */
+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)	0
+
+/* Nonzero if type TYPE should be returned in memory.
+   Blocks and data types largers than 4 bytes cannot be returned
+   in the register (D + X = 4).  */
+#define RETURN_IN_MEMORY(TYPE)				\
+    ((TYPE_MODE (TYPE) == BLKmode)			\
+     ? (int_size_in_bytes (TYPE) > 4)			\
+     : (GET_MODE_SIZE (TYPE_MODE (TYPE)) > 4))
+
+/* Passing Arguments in Registers.  */
+
+/* Define a data type for recording info about an argument list
+   during the scan of that argument list.  This data type should
+   hold all necessary information about the function itself
+   and about the args processed so far, enough to enable macros
+   such as FUNCTION_ARG to determine where the next arg should go.  */
+
+typedef struct {
+	int words;
+	int nregs;
+	int regno;
+} CUMULATIVE_ARGS;
+
+
+/*#define RESET_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME) */
+
+/* A C expression that indicates when an argument must be passed by reference.
+   If nonzero for an argument, a copy of that argument is made in memory and a
+   pointer to the argument is passed instead of the argument itself.
+   The pointer is passed in whatever way is appropriate for passing a pointer
+   to that type.
+ 
+   64-bit numbers are passed by reference.  */
+#if 0
+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \
+    m68hc11_function_arg_pass_by_reference (& (CUM), (MODE), (TYPE), (NAMED))
+#endif
+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)  0
+
+
+/* If defined, a C expression which determines whether, and in which direction,
+   to pad out an argument with extra space.  The value should be of type
+   `enum direction': either `upward' to pad above the argument,
+   `downward' to pad below, or `none' to inhibit padding.
+
+   Structures are stored left shifted in their argument slot.  */
+#if 0
+#define FUNCTION_ARG_PADDING(MODE, TYPE) \
+  m68hc11_function_arg_padding ((MODE), (TYPE))
+#endif
+
+#if 0
+#undef PAD_VARARGS_DOWN
+#define PAD_VARARGS_DOWN \
+  (m68hc11_function_arg_padding (TYPE_MODE (type), type) == downward)
+#endif
+
+/* A C expression that indicates when it is the called function's
+   responsibility to make a copy of arguments passed by invisible
+   reference.  Normally, the caller makes a copy and passes the
+   address of the copy to the routine being called.  When
+   FUNCTION_ARG_CALLEE_COPIES is defined and is nonzero, the caller
+   does not make a copy.  Instead, it passes a pointer to the "live"
+   value.  The called function must not modify this value.  If it can
+   be determined that the value won't be modified, it need not make a
+   copy; otherwise a copy must be made.  */
+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)		\
+    ((NAMED) && FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to a
+   function whose data type is FNTYPE. For a library call, FNTYPE is 0.  */
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \
+	logic32_init_cumulative_args(&(CUM), (FNTYPE), (LIBNAME), (INDIRECT))
+
+/* Update the data in CUM to advance over an argument of mode MODE and data
+   type TYPE. (TYPE is null for libcalls where that information may not be
+   available.) */
+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \
+	logic32_function_arg_advance(&CUM, MODE, TYPE, NAMED)
+
+/* Define where to put the arguments to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
+
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+    This is null for libcalls where that information may
+    not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+    the preceding args and about the function being called.
+   NAMED is nonzero if this argument is a named parameter
+    (otherwise it is an extra parameter matching an ellipsis).  */
+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) logic32_function_arg(&(CUM), (MODE), (TYPE), (NAMED))
+
+/* Define the profitability of saving registers around calls.
+
+   Disable this because the saving instructions generated by
+   caller-save need a reload and the way it is implemented,
+   it forbids all spill registers at that point.  Enabling
+   caller saving results in spill failure.  */
+#define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0
+
+/* For an arg passed partly in registers and partly in memory,
+   this is the number of registers used.
+   For args passed entirely in registers or entirely in memory, zero.
+
+   Passing an arg partly in register and memory does not work at all.
+   Don't do that.  */
+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) (0)
+
+/* 1 if N is a possible register number for function argument passing. */
+#define	MAX_LOGIC32_PARM_REGS		4
+#define	FIRST_ARG_REGNO				4
+#define FUNCTION_ARG_REGNO_P(N)		(N < FIRST_ARG_REGNO + MAX_LOGIC32_PARM_REGS  && N >= FIRST_ARG_REGNO)
+
+/* If defined, the maximum amount of space required for outgoing
+   arguments will be computed and placed into the variable
+   `current_function_outgoing_args_size'.  No space will be pushed
+   onto the stack for each call; instead, the function prologue should
+   increase the stack frame size by this amount.  */
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+/* If defined, a C expression whose value is nonzero when we want to use PUSH
+   instructions to pass outgoing arguments.  */
+#define PUSH_ARGS	(!ACCUMULATE_OUTGOING_ARGS)
+
+
+/* All return values are in the D or X+D registers:
+    - 8 and 16-bit values are returned in D.
+      BLKmode are passed in D as pointer.
+    - 32-bit values are returned in X + D.
+      The high part is passed in X and the low part in D.
+      For GCC, the register number must be HARD_X_REGNUM.  */
+
+#define	RET_REGNO	2
+#define	FUNCTION_VALUE(VALTYPE, FUNC)	gen_rtx_REG(TYPE_MODE(VALTYPE), RET_REGNO)
+
+/* Define how to find the value returned by a library function
+   assuming the value has mode MODE.  */
+#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, 0)
+
+/* 1 if N is a possible register number for a function value.  */
+#define FUNCTION_VALUE_REGNO_P(REGNO) ((REGNO) == RET_REGNO )
+
+#define STRUCT_VALUE  0
+#define STRUCT_VALUE_INCOMING  0
+
+/* Register in which address to store a structure value is passed to a
+   function.  */
+#if 0
+#define STRUCT_VALUE_REGNUM	HARD_D_REGNUM
+#endif
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
+   the stack pointer does not matter.  The value is tested only in functions
+   that have frame pointers. No definition is equivalent to always zero.  */
+#define EXIT_IGNORE_STACK	0
+
+
+/* Generating Code for Profiling.  */
+
+/* Output assembler code to FILE to increment profiler label # LABELNO
+   for profiling a function entry.  */
+#define FUNCTION_PROFILER(FILE, LABELNO)
+
+/* Length in units of the trampoline for entering a nested function.  */
+#define TRAMPOLINE_SIZE (32+16)
+/* The alignment of a trampoline, in bits.  */
+#define TRAMPOLINE_ALIGNMENT  32
+
+
+/* A C statement to initialize the variable parts of a trampoline.
+   ADDR is an RTX for the address of the trampoline; FNADDR is an
+   RTX for the address of the nested function; STATIC_CHAIN is an
+   RTX for the static chain value that should be passed to the
+   function when it is called.  */
+#if 0
+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \
+  logic32_initialize_trampoline ((TRAMP), (FNADDR), (CXT))
+#endif
+
+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)  \
+{									\
+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 32+4)),	\
+		  (CXT));						\
+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 32+0)),	\
+		  (FNADDR));						\
+}
+
+/* Addressing modes, and classification of registers for them.  */
+
+/* These assume that REGNO is a hard or pseudo reg number. They give nonzero
+   only if REGNO is a hard reg of the suitable class or a pseudo reg currently
+   allocated to a suitable hard reg.  Since they use reg_renumber, they are
+   safe only once reg_renumber has been allocated, which happens in
+   local-alloc.c.  */
+
+
+/* Internal macro, return 1 if REGNO is a valid base register.  */
+#define REG_VALID_P(REGNO) (1)	/* ? */
+
+#define REG_VALID_FOR_BASE_P(REGNO) \
+    (REG_VALID_P (REGNO) && (REGNO) < FIRST_PSEUDO_REGISTER )
+
+/* Internal macro, return 1 if REGNO is a valid index register.  */
+#define REG_VALID_FOR_INDEX_P(REGNO) \
+    (REG_VALID_P (REGNO) >= 0 && (REGNO) < FIRST_PSEUDO_REGISTER )
+
+/* Internal macro, the nonstrict definition for REGNO_OK_FOR_BASE_P.  */
+#define REGNO_OK_FOR_BASE_NONSTRICT_P(REGNO) \
+    ((REGNO) >= FIRST_PSEUDO_REGISTER \
+     || REG_VALID_FOR_BASE_P (REGNO) \
+     || (REGNO) == FRAME_POINTER_REGNUM \
+     || (REGNO) == ARG_POINTER_REGNUM \
+     || (reg_renumber && REG_VALID_FOR_BASE_P (reg_renumber[REGNO])))
+
+/* Internal macro, the nonstrict definition for REGNO_OK_FOR_INDEX_P.  */
+#define REGNO_OK_FOR_INDEX_NONSTRICT_P(REGNO) \
+    ( ((REGNO) >= FIRST_PSEUDO_REGISTER \
+	 || REG_VALID_FOR_INDEX_P (REGNO) \
+	 || (reg_renumber && REG_VALID_FOR_INDEX_P (reg_renumber[REGNO]))))
+
+/* Internal macro, the strict definition for REGNO_OK_FOR_BASE_P.  */
+#define REGNO_OK_FOR_BASE_STRICT_P(REGNO) \
+    ( (REGNO) < FIRST_PSEUDO_REGISTER ? REG_VALID_FOR_BASE_P (REGNO) \
+     : (reg_renumber && REG_VALID_FOR_BASE_P (reg_renumber[REGNO])))
+
+/* Internal macro, the strict definition for REGNO_OK_FOR_INDEX_P.  */
+#define REGNO_OK_FOR_INDEX_STRICT_P(REGNO) \
+    ( ((REGNO) < FIRST_PSEUDO_REGISTER ? REG_VALID_FOR_INDEX_P (REGNO) \
+         : (reg_renumber && REG_VALID_FOR_INDEX_P (reg_renumber[REGNO]))))
+
+#define REGNO_OK_FOR_BASE_P2(REGNO,STRICT) \
+    ((STRICT) ? (REGNO_OK_FOR_BASE_STRICT_P (REGNO)) \
+              : (REGNO_OK_FOR_BASE_NONSTRICT_P (REGNO)))
+
+#define REGNO_OK_FOR_INDEX_P2(REGNO,STRICT) \
+    ((STRICT) ? (REGNO_OK_FOR_INDEX_STRICT_P (REGNO)) \
+              : (REGNO_OK_FOR_INDEX_NONSTRICT_P (REGNO)))
+
+#define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_BASE_STRICT_P (REGNO)
+#define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_INDEX_STRICT_P (REGNO)
+
+#define REG_OK_FOR_BASE_STRICT_P(X)     REGNO_OK_FOR_BASE_STRICT_P (REGNO (X))
+#define REG_OK_FOR_BASE_NONSTRICT_P(X)  REGNO_OK_FOR_BASE_NONSTRICT_P (REGNO (X))
+#define REG_OK_FOR_INDEX_STRICT_P(X)    REGNO_OK_FOR_INDEX_STRICT_P (REGNO (X))
+#define REG_OK_FOR_INDEX_NONSTRICT_P(X) REGNO_OK_FOR_INDEX_NONSTRICT_P (REGNO (X))
+
+/* 1 if X is an rtx for a constant that is a valid address.  */
+#define CONSTANT_ADDRESS_P(X)	(CONSTANT_P (X))
+
+/* Maximum number of registers that can appear in a valid memory address */
+#define MAX_REGS_PER_ADDRESS	1
+
+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a
+   valid memory address for an instruction. The MODE argument is the
+   machine mode for the MEM expression that wants to use this address.  */
+/* Go to ADDR if X is a valid address.  */
+#ifndef REG_OK_STRICT
+#define	GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)	\
+	do {	\
+		if ( logic32_legitimate_address( (MODE), (X), 0) ) goto ADDR;	\
+	} while(0)
+#else
+#define	GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)	\
+	do {	\
+		if ( logic32_legitimate_address ((MODE), (X), 1) ) goto ADDR;	\
+	} while(0)
+#endif
+
+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check its
+   validity for a certain class.  We have two alternate definitions for each
+   of them.  The usual definition accepts all pseudo regs; the other rejects
+   them unless they have been allocated suitable hard regs.  The symbol
+   REG_OK_STRICT causes the latter definition to be used.
+  
+   Most source files want to accept pseudo regs in the hope that they will
+   get allocated to the class that the insn wants them to be in. Source files
+   for reload pass need to be strict. After reload, it makes no difference,
+   since pseudo regs have been eliminated by then.  */
+
+#ifndef REG_OK_STRICT
+/* Nonzero if X is a hard reg that can be used as a base reg.  */
+#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_NONSTRICT_P(X)
+
+/* Nonzero if X is a hard reg that can be used as an index.  */
+#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_NONSTRICT_P(X)
+#else
+#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_STRICT_P(X)
+#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_STRICT_P(X)
+#endif
+
+
+/* Try machine-dependent ways of modifying an illegitimate address
+   to be legitimate.  If we find one, return the new, valid address.
+   This macro is used in only one place: `memory_address' in explow.c.
+  
+   OLDX is the address as it was before break_out_memory_refs was called.
+   In some cases it is useful to look at this to decide what needs to be done.
+  
+   MODE and WIN are passed so that this macro can use
+   GO_IF_LEGITIMATE_ADDRESS.
+  
+   It is always safe for this macro to do nothing.
+   It exists to recognize opportunities to optimize the output.  */
+
+#if 0
+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)                     \
+{ rtx operand = (X);                                            \
+  if (logic32_legitimize_address (&operand, (OLDX), (MODE)))	\
+    {                                                           \
+      (X) = operand;                                            \
+      GO_IF_LEGITIMATE_ADDRESS (MODE,X,WIN);                    \
+    }                                                           \
+}
+#endif
+#define LEGITIMIZE_ADDRESS(x, oldx, mode, win) 
+
+/* Go to LABEL if ADDR (a legitimate address expression)
+   has an effect that depends on the machine mode it is used for.  */
+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  \
+{									\
+  if (GET_CODE (ADDR) == PRE_DEC || GET_CODE (ADDR) == POST_DEC		\
+      || GET_CODE (ADDR) == PRE_INC || GET_CODE (ADDR) == POST_INC)	\
+    goto LABEL;								\
+}
+
+/* Nonzero if the constant value X is a legitimate general operand.
+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */
+
+#define LEGITIMATE_CONSTANT_P(X)	1
+
+/* Tell final.c how to eliminate redundant test instructions.  */
+/* Store in cc_status the expressions
+   that the condition codes will describe
+   after execution of an instruction whose pattern is EXP.
+   Do not alter them if the instruction would not alter the cc's.  */
+#define NOTICE_UPDATE_CC(exp, insn) CC_STATUS_INIT
+
+/* Move costs between classes of registers */
+#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)	4
+
+/* Move cost between register and memory. */
+#define MEMORY_MOVE_COST(MODE,CLASS,IN)				1
+
+/* A C expression for the cost of a branch instruction.  A value of 1
+   is the default; other values are interpreted relative to that.
+
+   Pretend branches are cheap because GCC generates sub-optimal code
+   for the default value.  */
+#define BRANCH_COST 0
+
+/* Nonzero if access to memory by bytes is slow and undesirable.
+   For RISC chips, it means that access to memory by bytes is no
+   better than access by words when possible, so grab a whole word
+   and maybe make use of that.  */
+#define SLOW_BYTE_ACCESS	0
+
+/* It is as good to call a constant function address as to call an address
+   kept in a register.  */
+#define NO_FUNCTION_CSE
+
+/* Try a machine-dependent way of reloading an illegitimate address
+   operand.  If we find one, push the reload and jump to WIN.  This
+   macro is used in only one place: `find_reloads_address' in reload.c.
+
+   For M68HC11, we handle large displacements of a base register
+   by splitting the addend across an addhi3 insn.
+
+   For M68HC12, the 64K offset range is available.
+   */
+
+
+/* Defining the Output Assembler Language.  */
+
+/* A default list of other sections which we might be "in" at any given
+   time.  For targets that use additional sections (e.g. .tdesc) you
+   should override this definition in the target-specific file which
+   includes this file.  */
+
+/* Output before read-only data.  */
+#define TEXT_SECTION_ASM_OP	("\t.section\t.text")
+
+/* Output before writable data.  */
+#define DATA_SECTION_ASM_OP	("\t.section\t.data")
+
+/* Output before uninitialized data.  */
+#define BSS_SECTION_ASM_OP 	("\t.section\t.bss")
+
+/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.
+
+   Same as config/elfos.h but don't mark these section SHF_WRITE since
+   there is no shared library problem.  */
+#undef CTORS_SECTION_ASM_OP
+#define CTORS_SECTION_ASM_OP	"\t.section\t.ctors,\"a\""
+
+#undef DTORS_SECTION_ASM_OP
+#define DTORS_SECTION_ASM_OP	"\t.section\t.dtors,\"a\""
+
+#if 0
+/* If defined, a function that outputs assembler code to arrange to
+   call the function referenced by SYMBOL at initialization time.  */
+#define TARGET_ASM_CONSTRUCTOR  logic32_asm_out_constructor
+
+/* This is like `TARGET_ASM_CONSTRUCTOR' but used for termination
+   functions rather than initialization functions.  */
+
+#define TARGET_ASM_DESTRUCTOR   logic32_asm_out_destructor
+#endif
+
+#define	INIT_SECTION_ASM_OP		"\t.section\t.init"
+#define	IDENT_ASM_OP			"\t.ident\t"
+#define	SET_ASM_OP				"\t.set\t"
+#define	GLOBAL_ASM_OP			"\t.globl\t"
+
+/* Comment character */
+#define ASM_COMMENT_START	";"
+
+/* Output to assembler file text saying following lines
+   may contain character constants, extra white space, comments, etc.  */
+#define ASM_APP_ON 		"; Begin inline assembler code\n#APP\n"
+
+/* Output to assembler file text saying following lines
+   no longer contain unusual constructs.  */
+#define ASM_APP_OFF 		"; End of inline assembler code\n#NO_APP\n"
+
+/* Write the extra assembler code needed to declare a function properly.
+   Some svr4 assemblers need to also have something extra said about the
+   function's return value.  We allow for that here.
+
+   For 68HC12 we mark functions that return with 'rtc'.  The linker
+   will ensure that a 'call' is really made (instead of 'jsr').
+   The debugger needs this information to correctly compute the stack frame.
+
+   For 68HC11/68HC12 we also mark interrupt handlers for gdb to
+   compute the correct stack frame.  */
+
+
+/* Output #ident as a .ident.  */
+
+/* output external reference */
+#define ASM_OUTPUT_EXTERNAL(FILE,DECL,NAME) \
+  {fputs ("\t; extern\t", FILE); \
+  assemble_name (FILE, NAME); \
+  fputs ("\n", FILE);}
+
+/* Print an instruction operand X on file FILE. CODE is the code from the
+   %-spec for printing this operand. If `%z3' was used to print operand
+   3, then CODE is 'z'.  */
+
+#define PRINT_OPERAND(FILE, X, CODE) \
+  logic32_print_operand (FILE, X, CODE)
+
+/* Print a memory operand whose address is X, on file FILE.  */
+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) \
+  logic32_print_operand_address (FILE, ADDR)
+
+/* This is how to output an insn to push/pop a register on the stack.
+   It need not be very fast code.  
+
+   Don't define because we don't know how to handle that with
+   the STATIC_CHAIN_REGNUM (soft register).  Saving the static
+   chain must be made inside FUNCTION_PROFILER.  */
+
+#if 0
+#undef ASM_OUTPUT_REG_PUSH
+#undef ASM_OUTPUT_REG_POP
+#endif
+
+/* This is how to output an element of a case-vector that is relative.  */
+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \
+  fprintf (FILE, "\t%s\tL%d-L%d\n", integer_asm_op (4, TRUE), VALUE, REL)
+
+/* This is how to output an element of a case-vector that is absolute.  */
+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \
+  fprintf (FILE, "\t%s\t.L%d\n", integer_asm_op (4, TRUE), VALUE)
+
+
+/* This is how to output an assembler line that says to advance the
+   location counter to a multiple of 2**LOG bytes.  */
+#define ASM_OUTPUT_ALIGN(FILE,LOG) \
+do { if ((LOG) != 0) fprintf (FILE, "\t.align %d\n", 1 << (LOG)); } while (0)
+
+/* Assembler Commands for Exception Regions.  */
+
+/* Default values provided by GCC should be ok. Assuming that DWARF-2
+   frame unwind info is ok for this platform.  */
+
+#undef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+
+/* For the support of memory banks we need addresses that indicate
+   the page number.  */
+#define DWARF2_ADDR_SIZE 4
+
+/* SCz 2003-07-08: Don't use as dwarf2 .file/.loc directives because
+   the linker is doing relaxation and it does not adjust the debug_line
+   sections when it shrinks the code.  This results in invalid addresses
+   when debugging.  This does not bless too much the HC11/HC12 as most
+   applications are embedded and small, hence a reasonable debug info.
+   This problem is known for binutils 2.13, 2.14 and mainline.   */
+#undef HAVE_AS_DWARF2_DEBUG_LINE
+
+/* The prefix for local labels.  You should be able to define this as
+   an empty string, or any arbitrary string (such as ".", ".L%", etc)
+   without having to make any other changes to account for the specific
+   definition.  Note it is a string literal, not interpreted by printf
+   and friends.  */
+#define LOCAL_LABEL_PREFIX "."
+
+/* The prefix for immediate operands.  */
+#define IMMEDIATE_PREFIX "#"
+
+/* Miscellaneous Parameters.  */
+
+/* Define the codes that are matched by predicates in logic32.c.  */
+
+/* Specify the machine mode that this machine uses
+   for the index in the tablejump instruction.  */
+#define CASE_VECTOR_MODE	Pmode
+
+/* This flag, if defined, says the same insns that convert to a signed fixnum
+   also convert validly to an unsigned one.  */
+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC
+
+/* Max number of bytes we can move from memory to memory in one
+   reasonably fast instruction.  */
+
+/* MOVE_RATIO is the number of move instructions that is better than a
+   block move.  Make this small on logic32, since the code size grows very
+   large with each move.  */
+#define MOVE_RATIO		3
+
+/* Define if shifts truncate the shift count which implies one can omit
+   a sign-extension or zero-extension of a shift count.  */
+#define SHIFT_COUNT_TRUNCATED	1
+
+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits
+   is done just by pretending it is already truncated.  */
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)	1
+
+/* Specify the machine mode that pointers have. After generation of rtl, the
+   compiler makes no further distinction between pointers and any other
+   objects of this machine mode.  */
+#define Pmode				SImode
+
+/* A function address in a call instruction is a byte address (for indexing
+   purposes) so give the MEM rtx a byte's mode.  */
+#define FUNCTION_MODE		SImode
+
+/*
+#define TARGET_FLOAT_FORMAT  IEEE_FLOAT_FORMAT
+*/
+
diff -Naur gcc-3.4.2/gcc/config/logic32/logic32.md ../gcc-3.4.2/gcc/config/logic32/logic32.md
--- gcc-3.4.2/gcc/config/logic32/logic32.md	1970-01-01 08:00:00.000000000 +0800
+++ ../gcc-3.4.2/gcc/config/logic32/logic32.md	2019-06-10 22:23:13.000000000 +0800
@@ -0,0 +1,554 @@
+
+(define_constants
+  [ (LOGIC32_SP 29) ]
+)
+
+;; Register numbers
+;(define_constants
+  ;[(IP_REGNUM	    12)		; Scratch register
+   ;(SP_REGNUM	    13)		; Stack pointer
+   ;(LR_REGNUM       14)		; Return address register
+   ;(PC_REGNUM	    15)		; Program counter
+   ;(CC_REGNUM       24)		; Condition code pseudo register
+   ;(LAST_ARM_REGNUM 15)
+  ;]
+;)
+
+;; Attributes
+;; define attribute mode
+(define_attr "mode" "unknown,none,QI,HI,SI,SF" (const_string "unknown"))
+
+;; define attribute type
+(define_attr "type" "move,unary,binary,compare,shift,mult,div,arith,logical,uncond_branch,branch,call,call_no_delay_slot,nop,jmp" (const_string "binary"))
+
+;; define mode enumlator MOVE_MODE, CMP_MODE and D_MODE
+;(define_mode_iterator MOV_MODE [SI SF QI])
+;(define_mode_iterator CMP_MODE [SI SF])
+;(define_mode_iterator D_MODE [SI SF])
+
+;; data move instructions
+
+;; Push a register onto the stack
+(define_insn "movsi_push"
+  [(set (mem:SI (pre_dec:SI (reg:SI LOGIC32_SP)))
+    (match_operand:SI 0 "register_operand" "r"))]
+  ""  
+  "push %0")
+
+;; Pop a register from the stack
+(define_insn "movsi_pop"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+    (mem:SI (post_inc:SI (reg:SI LOGIC32_SP))))]
+  ""  
+  "pop %0")
+
+(define_insn "store_reg"
+	[(set (mem:SI (plus:SI (reg:SI LOGIC32_SP) (match_operand:SI 0 "immediate_operand" "i")))
+		(match_operand:SI 1 "register_operand" "r"))]
+	""
+	"sw %0($sp), %1	; store from sp"
+	[(set_attr "type" "arith") (set_attr "mode" "SI")])
+
+(define_insn "load_reg"
+	[(set (match_operand:SI 0 "register_operand" "=r")
+		(mem:SI (plus:SI (reg:SI LOGIC32_SP) (match_operand:SI 1 "immediate_operand" "i"))))]
+	""
+	"lw %0, %1($sp) ; load form sp"
+	[(set_attr "type" "arith") (set_attr "mode" "SI")])
+
+;; mov instruction templater
+(define_insn "movsi"
+	[(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,m")
+		(match_operand:SI 1 "general_operand" "r,i,m,r"))]
+	""
+	"@
+	mov %0, %1
+	ldi %0, %1
+	lw %0, %1
+	sw %0, %1 ; movsi"
+	[(set_attr "type" "arith") (set_attr "mode" "SI")])
+
+(define_insn "movqi"
+	[(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,r,m")
+		(match_operand:QI 1 "general_operand" "r,i,m,r"))]
+	""
+	"@
+	movb %0, %1
+	ldbi %0, %1
+	lb %0, %1
+	sb %0, %1"
+	[(set_attr "type" "arith") (set_attr "mode" "SI")])
+
+(define_insn "movhi"
+	[(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,r,m")
+		(match_operand:HI 1 "general_operand" "r,i,m,r"))]
+	""
+	"@
+	movh %0, %1
+	ldhi %0, %1
+	lh %0, %1
+	sh %0, %1"
+	[(set_attr "type" "arith") (set_attr "mode" "SI")])
+
+;(define_insn "movhi"
+  ;[(set (match_operand:HI 0 "nonimmediate_operand" "")
+	;(match_operand:HI 1 "general_operand" ""))]
+	;""
+	;"movh %0, %1"
+	;[(set_attr "type" "arith") (set_attr "mode" "HI")])
+
+
+;; arithmetic instructions
+;; define code enumlator
+;(define_code_iterator arith_op [plus minus mult div])
+;(define_code_attr op_name [(plus "add") (minus "sub") (mult "mul") (div "div")])
+;(define_code_attr inst_name [(plus "ADD") (minus "SUB") (mult "MULT") (div "DIV")])
+;(define_code_attr op_type [(plus "arith") (minus "arith") (mult "mult") (div "div")])
+;(define_mode_attr dm [(SI "") (SF "F")])
+
+;; ADD, SUB, MULT, DIV, ADDF, SUBF, MULTF, DIVF instruction templater
+(define_insn "addsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+	(plus:SI (match_operand:SI 1 "register_operand" "r,r") (match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	add %0, %1, %2
+	addi %0, %1, %2"
+	[(set_attr "type" "arith")
+	(set_attr "mode" "SI")])
+
+(define_insn "subsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+	(minus:SI (match_operand:SI 1 "register_operand" "r,r") (match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	sub %0, %1, %2
+	subi %0, %1, %2"
+	[(set_attr "type" "arith")
+	(set_attr "mode" "SI")])
+
+(define_insn "mulsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+	(mult:SI (match_operand:SI 1 "register_operand" "r,r") (match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	mul %0, %1, %2
+	muli %0, %1, %2"
+	[(set_attr "type" "arith")
+	(set_attr "mode" "SI")])
+
+(define_insn "divsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+	(div:SI (match_operand:SI 1 "register_operand" "r,r") (match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	div %0, %1, %2
+	divi %0, %1, %2"
+	[(set_attr "type" "arith")
+	(set_attr "mode" "SI")])
+
+(define_insn "modsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+	(mod:SI (match_operand:SI 1 "register_operand" "r,r") (match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	mod %0, %1, %2
+	modi %0, %1, %2"
+	[(set_attr "type" "arith")
+	(set_attr "mode" "SI")])
+
+;; booleam instructions
+;(define_code_iterator bool_op [and ior xor])
+;(define_code_attr bool_name [(and "and") (ior "ior") (xor "xor")])
+;(define_code_attr bool_insn_name [(and "AND") (ior "OR") (xor "XOR")])
+;; AND, OR, XOR instruction templater
+
+(define_insn "andsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+	(and:SI (match_operand:SI 1 "register_operand" "r,r") (match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	and %0, %1, %2
+	andi %0, %1, %2"
+	[(set_attr "type" "logical")
+	(set_attr "mode" "SI")])
+
+(define_insn "iorsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+	(ior:SI (match_operand:SI 1 "register_operand" "r,r") (match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	or %0, %1, %2
+	ori %0, %1, %2"
+	[(set_attr "type" "logical")
+	(set_attr "mode" "SI")])
+
+(define_insn "xorsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+	(xor:SI (match_operand:SI 1 "register_operand" "r,r") (match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	xor %0, %1, %2
+	xori %0, %1, %2"
+	[(set_attr "type" "logical")
+	(set_attr "mode" "SI")])
+
+;; NOT instruction templater
+(define_insn "one_cmplsi2"
+	[(set (match_operand:SI 0 "register_operand" "=r") (not:SI (match_operand:SI 1 "register_operand" "r")))]
+	""
+	"not %0, %1"
+	[(set_attr "type" "logical")
+	(set_attr "mode" "SI")])
+
+;; shift instruction
+;(define_code_iterator shift_op [ashift ashiftrt])
+;(define_code_attr shift_name [(ashift "ashl") (ashiftrt "ashr")])
+;(define_code_attr shift_insn_name [(ashift "SLL") (ashiftrt "SRL")])
+
+;; arith shift left
+(define_insn "ashlsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+	(ashift:SI (match_operand:SI 1 "register_operand" "r,r") (match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	asl %0, %1, %2
+	asli %0, %1, %2"
+	[(set_attr "type" "shift")
+	(set_attr "mode" "SI")])
+
+;; arith shift right
+(define_insn "ashrsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+	(ashiftrt:SI (match_operand:SI 1 "register_operand" "r,r") (match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	asr %0, %1, %2
+	asri %0, %1, %2"
+	[(set_attr "type" "shift")
+	(set_attr "mode" "SI")])
+
+;; logic shift right
+(define_insn "lshrsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+	(lshiftrt:SI (match_operand:SI 1 "register_operand" "r,r") (match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	lsr %0, %1, %2
+	lsri %0, %1, %2"
+	[(set_attr "type" "shift")
+	(set_attr "mode" "SI")])
+
+;; compare instruction
+;;(define_expand "cmpsi"
+	;;[(set (reg:CC 61)
+		;;(compare:CC (match_operand:SI 0 "register_operand" "")
+		;;(match_operand:SI 1 "register_operand" "")))]
+	;;""
+	;;"
+	;;{
+		;;//logic32_compare_op0 = operands[0];
+		;;//logic32_compare_op1 = operands[1];
+		;;DONE;
+	;;}"
+;;)
+
+(define_insn "cmpsi"
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "r")
+		 (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  "cmp %0,%1")
+
+(define_insn "beq"
+  [(set (pc)
+	(if_then_else (eq (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "beq %l0")
+
+(define_insn "bne"
+  [(set (pc)
+	(if_then_else (ne (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "bne %l0")
+
+(define_insn "bgt"
+  [(set (pc)
+	(if_then_else (gt (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "bgt %l0")
+
+(define_insn "bge"
+  [(set (pc)
+	(if_then_else (ge (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "bge %l0")
+
+(define_insn "blt"
+  [(set (pc)
+	(if_then_else (lt (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "blt %l0")
+
+(define_insn "ble"
+  [(set (pc)
+	(if_then_else (le (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "ble %l0")
+
+(define_insn "bgtu"
+  [(set (pc)
+	(if_then_else (gtu (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "bgtu %l0")
+
+(define_insn "bgeu"
+  [(set (pc)
+	(if_then_else (geu (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "bgeu %l0")
+
+(define_insn "bltu"
+  [(set (pc)
+	(if_then_else (ltu (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "bltu %l0")
+
+(define_insn "bleu"
+  [(set (pc)
+	(if_then_else (leu (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "bleu %l0")
+
+;(define_code_iterator any_cond [eq ne gt lt ge le])
+;;(define_expand "beq"
+	;;[(set (pc)
+	;;(if_then_else (eq (match_dup 1) (const_int 0))
+				;;(label_ref (match_operand 0 "" ""))
+				;;(pc)))]
+	;;""
+	;;"
+	;;{
+		;;//operands[1] = gen_compare_reg (<CODE>, logic32_compare_op0, logic32_compare_op1);
+	;;}")
+
+;;(define_expand "beqf"
+	;;[(set (pc)
+		;;(if_then_else (eq (match_dup 1) (const_int 0))
+				;;(label_ref (match_operand 0 "" ""))
+				;;(pc)))]
+	;;""
+	;;"
+	;;{
+		;;//operands[1] = gen_compare_reg (<CODE>, logic32_compare_op0, logic32_compare_op1);
+	;;}")
+
+;; Now match both normal and inverted jump.
+;;(define_insn "cbranchsi4"
+	;;[(set (pc) (if_then_else (match_operator:SI 0 "comparison_operator"
+	;;[(match_operand:SI 1 "nonimmediate_operand" "")
+	;;(match_operand:SI 2 "nonimmediate_operand" "") ])
+		;;(label_ref (match_operand 3 "" ""))
+	;;(pc)))]
+	;;""
+	;;{
+		;;char str[15], str1[40];
+		;;sprintf(str, "%s", rtx_name[GET_CODE(operands[0])]);
+		;;sprintf(str1, "%s %%1, %%2, %%13", str);
+		;;switch(GET_CODE(operands[0]))
+		;;{
+			;;case EQ: return "beq	%1, %2, %l3";
+			;;case NE: return "bne	%1, %2, %l3";
+			;;case LT: return "blt	%1, %2, %l3";
+			;;case LE: return "ble	%1, %2, %l3";
+			;;case GT: return "bgt	%1, %2, %l3";
+			;;case GE: return "bge	%1, %2, %l3";
+;;
+			;;case LEU: return "bleu	%1, %2, %l3";
+			;;case GEU: return "bgeu	%1, %2, %l3";
+			;;case GTU: return "bgtu	%1, %2, %l3";
+			;;case LTU: return "bltu	%1, %2, %l3";
+;;
+			;;default: return str1;
+		;;}
+	;;}
+	;;[(set_attr "type" "compare")
+	;;(set_attr "mode" "SI")])
+
+;;(define_insn "cbranchsf4"
+	;;[(set (pc) (if_then_else
+		;;(match_operator:SF 0 "comparison_operator"
+		;;[(match_operand:SF 1 "nonimmediate_operand" "")
+		 ;;(match_operand:SF 2 "nonimmediate_operand" "")])
+		;;(label_ref (match_operand 3 "" ""))
+		;;(pc)))]
+	;;""
+	;;{
+		;;char str[15], str1[40];
+		;;sprintf(str, "%s", rtx_name[GET_CODE(operands[0])]);
+		;;sprintf(str1, "%s %%1, %%2, %%13", str);
+		;;switch(GET_CODE(operands[0]))
+		;;{
+			;;case EQ: return "EQF	%1, %2, %l3";
+			;;case NE: return "NEF	%1, %2, %l3";
+			;;case LT: return "LTF	%1, %2, %l3";
+			;;case LE: return "LEF	%1, %2, %l3";
+			;;case GT: return "GTF	%1, %2, %l3";
+			;;case GE: return "GEF	%1, %2, %l3";
+			;;default: return str1;
+		;;}
+	;;}
+	;;[(set_attr "type" "compare")
+	;;(set_attr "mode" "SF")])
+
+;; uncondition jump JUMP instruction templater
+(define_insn "jump"
+	[(set (pc) (label_ref (match_operand 0 "" "")))]
+	""
+	"jmp %l0"
+)
+
+;; indirect jump J instruction templater
+(define_insn "indirect_jump"
+	[(set (pc) (match_operand:SI 0 "address_operand" "p"))]
+	""
+	"jmpr %a0"
+)
+
+
+;; function call instruction
+(define_insn "call_value"
+	[(set (match_operand:SI 0 "general_operand" "")
+	(call (match_operand:SI 1 "general_operand" "") (match_operand:SI 2 "general_operand" "")))
+	]
+	""
+	"jal %1	; call value"	;;"%0=CALL %1 with %c2 number of parameters"
+)
+
+
+;; Subroutine call instruction returning no value.  Operand 0 is the function
+;; to call; operand 1 is the number of bytes of arguments pushed (in mode
+;; `SImode', except it is normally a `const_int'); operand 2 is the number of
+;; registers used as operands.
+
+;; On most machines, operand 2 is not actually stored into the RTL pattern.  It
+;; is supplied for the sake of some RISC machines which need to put this
+;; information into the assembler code; they can put it in the RTL instead of
+;; operand 1.
+
+(define_insn "call"
+	[(parallel [(call (match_operand:SI 0 "" "") (match_operand:SI 1 "" ""))
+		(clobber (reg:SI 31))])]
+	""
+	"call %0, %1")
+
+;; RETURN instruction templater
+(define_insn "return"
+	[(set (pc) (return))]
+	""
+	"ret"
+)
+
+;; type convert instructions
+(define_insn "floatsisf2"
+	[(set (match_operand:SF 0 "register_operand" "=r")
+	(float:SF (match_operand:SI 1 "register_operand" "r")))]
+	""
+	"cvti2f %0, %1"
+)
+
+(define_insn "fix_truncsfsi2"
+	[(set (match_operand:SI 0 "register_operand" "=r")
+	(fix:SI (match_operand:SF 1 "register_operand" "r")))]
+	""
+	"cvtf2i %0, %1"
+)
+
+;; nop NOP instruction templater
+(define_insn "nop"
+	[(const_int 0)]
+	""
+	"nop"
+)
+
+;; dummy test instruction
+(define_insn "dummy_pattern"
+	[(reg:SI 0)]
+	"1"
+	"This is just empty!"
+)
+
+
+(define_expand "prologue"
+	[(const_int 1)] 
+	""  
+	"
+	{
+		logic32_expand_prologue ();
+		DONE;
+	}"
+)
+
+(define_expand "epilogue"
+	[(const_int 2)] 
+	""  
+	"
+	{
+		logic32_expand_epilogue ();
+		DONE;
+	}"
+)
+
+
+(define_insn "negsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(neg:SI (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  "neg %0, %1"
+  [(set_attr "type" "unary")])
+
+;;--------------------------------------------------------------------
+;;-  Table jump
+;;--------------------------------------------------------------------
+;;
+;; Operand 0 is the address of the table element to use
+;; operand 1 is the CODE_LABEL for the table
+;;--------------------------------------------------------------------
+(define_insn "tablejump"
+  [(set (pc)
+	(match_operand:SI 0 "register_operand" "r"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  "jmpr	%0"
+  [(set_attr "type" "jmp")])
+
diff -Naur gcc-3.4.2/gcc/config/logic32/logic32-modes.def ../gcc-3.4.2/gcc/config/logic32/logic32-modes.def
--- gcc-3.4.2/gcc/config/logic32/logic32-modes.def	1970-01-01 08:00:00.000000000 +0800
+++ ../gcc-3.4.2/gcc/config/logic32/logic32-modes.def	2019-06-02 10:47:50.000000000 +0800
@@ -0,0 +1,20 @@
+/* Definitions of target machine for GCC for logic32
+   Copyright (C) 2002 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
diff -Naur gcc-3.4.2/gcc/config/logic32/logic32-protos.h ../gcc-3.4.2/gcc/config/logic32/logic32-protos.h
--- gcc-3.4.2/gcc/config/logic32/logic32-protos.h	1970-01-01 08:00:00.000000000 +0800
+++ ../gcc-3.4.2/gcc/config/logic32/logic32-protos.h	2019-06-02 10:47:50.000000000 +0800
@@ -0,0 +1,121 @@
+/* Prototypes for exported functions defined in m68hc11.c
+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+   Contributed by Stephane Carrez (stcarrez@nerim.fr)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+
+
+extern void logic32_expand_move (enum machine_mode, rtx, rtx);
+void logic32_print_operand (FILE *file, rtx op, int letter);
+int hard_register_operand (rtx op, enum machine_mode mode);
+int soft_register_operand (rtx op, enum machine_mode mode);
+int hard_memory_operand (rtx op, enum machine_mode mode);
+int stack_pointer_operand (rtx op, enum machine_mode mode);
+int any_operand (rtx op, enum machine_mode mode);
+int any_nonimmediate_operand (rtx op, enum machine_mode mode);
+int any_operator (rtx op, enum machine_mode mode);
+
+int address_plus_operand (register rtx op, enum machine_mode mode);
+const char *generate_jump(rtx loc, rtx insn);
+#ifdef RTX_CODE
+const char *generate_branch(enum rtx_code code, rtx loc, rtx insn);
+#endif
+
+const char *logic32_generate_move(rtx operands[], rtx insn);
+const char *logic32_changestackpointer(rtx operands[], rtx insn);
+const char *logic32_generate_if_then_else(rtx operands[], rtx insn);
+const char *logic32_generate_if_zero_then_else(rtx operands[], rtx insn);
+const char *logic32_generate_if_not_zero_then_else(rtx operands[], rtx insn);
+const char *logic32_generate_reload(rtx operands[], rtx insn);
+void logic32_prologue(FILE *file, HOST_WIDE_INT size);
+void logic32_epilogue(FILE *file, HOST_WIDE_INT size);
+const char *logic32_generate_binop(rtx operands[], rtx insn, const char *binop);
+int logic32_legitimate_address(enum machine_mode mode, rtx x, int strict);
+const char *logic32_generate_conditional_move(rtx operands[], rtx insn);
+const char *logic32_jump(rtx operands[], rtx insn);
+const char *logic32_jump_pcrel(rtx operands[], rtx insn);
+const char *logic32_push(rtx operands[], rtx insn);
+int logic32_nonimmediate(rtx op, enum machine_mode mode);
+int logic32_initial_elimination_offset (int from, int to);
+void logic32_expand_epilogue (void);
+void logic32_expand_prologue (void);
+rtx logic32_return_addr_rtx(void);
+const char *logic32_call(rtx operands[], rtx insn);
+const char *logic32_call_value(rtx operands[], rtx insn);
+
+void logic32_start_asm(FILE *file);
+const char * logic32_asm_multi(const char *format, rtx *operands, int byteCount);
+int operand_check (char c, rtx op);
+const char *logic32_table_jump(rtx operands[], rtx insn);
+
+void logic32_expand_set(enum machine_mode mode, rtx operands[]);
+const char *logic32_call(rtx operands[], rtx insn);
+int logic32_binary_operator (rtx op  ATTRIBUTE_UNUSED, enum machine_mode mode ATTRIBUTE_UNUSED);
+int logic32_unary_operator (rtx op  ATTRIBUTE_UNUSED, enum machine_mode mode ATTRIBUTE_UNUSED);
+int logic32_return_pops_args (tree fundecl ATTRIBUTE_UNUSED, tree funtype, int size);
+extern bool logic32_extra_constraint (rtx, int);
+const char *logic32_generate_set(rtx insn);
+int
+move_double_dest_operand (rtx op, enum machine_mode mode);
+int
+move_double_src_operand (rtx op, enum machine_mode mode);
+rtx
+gen_split_move_double (rtx operands[]);
+
+
+
+
+bool logic32_regno_mode_ok_for_base_p(int regno, enum machine_mode mode, bool strict_p);
+
+enum logic32_address_type
+{
+	ADDRESS_REG,
+	BASE_ADDRESS_REG,
+	ADDRESS_CONST_INT,
+	ADDRESS_SYMBOLIC
+};
+
+struct logic32_address_info
+{
+	enum logic32_address_type type;
+	rtx reg;
+	rtx offset;
+	rtx base_rtx;
+};
+
+bool logic32_classify_address(struct logic32_address_info *addr_info, enum machine_mode mode, rtx addr_x, bool strict_p);
+
+void logic32_output_function_prologue(FILE *file, HOST_WIDE_INT size);
+
+void logic32_output_function_epilogue(FILE *file, HOST_WIDE_INT size);
+
+#ifndef Mmode
+#define Mmode enum machine_mode
+#endif
+
+int call_operand (rtx operand, Mmode mode ATTRIBUTE_UNUSED);
+
+void logic32_init_cumulative_args(CUMULATIVE_ARGS *cum, tree funtype, rtx libname, tree fndecl);
+
+void logic32_function_arg_advance(CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type, int named);
+
+rtx logic32_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode, tree type, int named);
+
+int logic32_arith_reg_operand (rtx op, enum machine_mode mode);
+
diff -Naur gcc-3.4.2/gcc/config/logic32/t-logic32-gas ../gcc-3.4.2/gcc/config/logic32/t-logic32-gas
--- gcc-3.4.2/gcc/config/logic32/t-logic32-gas	1970-01-01 08:00:00.000000000 +0800
+++ ../gcc-3.4.2/gcc/config/logic32/t-logic32-gas	2019-06-02 10:47:50.000000000 +0800
@@ -0,0 +1,76 @@
+RANLIB_FOR_TARGET = ` \
+  if [ -f $(objdir)/../binutils/ranlib ] ; then \
+    echo $(objdir)/../binutils/ranlib ; \
+  else \
+    if [ "$(host)" = "$(target)" ] ; then \
+      echo ranlib; \
+    else \
+       if [ -f $(bindir)/$(target_noncanonical)-ranlib ] ; then \
+	  echo $(bindir)/$(target_noncanonical)-ranlib ; \
+       else \
+          t='$(program_transform_cross_name)'; echo ranlib | sed -e $$t ; \
+       fi; \
+    fi; \
+  fi`
+
+T_CPPFLAGS = -DUSE_GAS
+
+
+
+LIB1ASMSRC = 
+LIB1ASMFUNCS = 
+
+TARGET_LIBGCC2_CFLAGS = -DUSE_GAS -DIN_GCC 
+
+# Here we enumerate all the fn's in arit.c
+LOGIC32_ARIT_FILES = _mulsi3.c _xordi3.c  
+
+LIB2FUNCS_EXTRA = $(srcdir)/config/udivmod.c $(srcdir)/config/divmod.c $(srcdir)/config/udivmodsi4.c $(LOGIC32_ARIT_FILES) 
+LOGIC32_LIB1CSRC = $(srcdir)/config/logic32/arit.c
+
+# Don't compile with -g1 this reduces the size of some sections (.eh_frame).
+# FIX!!! adding "-g" compiler option breaks -O3
+LIBGCC2_DEBUG_CFLAGS =
+LIBGCC2_CFLAGS =  $(LIBGCC2_INCLUDES) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) -DIN_LIBGCC2 $(MULTILIB_CFLAGS)
+
+# We want fine grained libraries, so use the new code to build the
+# floating point emulation libraries.
+
+
+FPBIT = fp-bit.c
+DPBIT = dp-bit.c
+
+dp-bit.c: $(srcdir)/config/fp-bit.c
+	echo '/* LOGIC32 dp-bit */' > dp-bit.c
+	cat $(srcdir)/config/fp-bit.c >> dp-bit.c
+
+fp-bit.c: $(srcdir)/config/fp-bit.c
+	echo '#define FLOAT' > fp-bit.c
+	cat $(srcdir)/config/fp-bit.c >> fp-bit.c
+
+
+# Assemble startup files.
+$(T)crti.o: $(srcdir)/config/logic32/crti.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/logic32/crti.asm
+
+$(T)crtn.o: $(srcdir)/config/logic32/crtn.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/logic32/crtn.asm
+
+# The fixed-point arithmetic code is in one file, arit.c,
+# similar to libgcc2.c (or the old libgcc1.c).  We need to
+# "split it up" with one file per define.
+$(LOGIC32_ARIT_FILES): $(LOGIC32_LIB1CSRC)
+	name=`echo $@ | sed -e 's,.*/,,' | sed -e 's,.c$$,,'`; \
+	echo "#define L$$name" > tmp-$@ \
+	&& echo '#include "$<"' >> tmp-$@ \
+	&& mv -f tmp-$@ $@
+
+MULTILIB_OPTIONS = Os/O2/O3
+MULTILIB_DIRNAMES = small fast ludicrous
+
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o  crti.o crtn.o
+
+LIBGCC = stmp-multilib
+INSTALL_LIBGCC = install-multilib
diff -Naur gcc-3.4.2/gcc/config.gcc ../gcc-3.4.2/gcc/config.gcc
--- gcc-3.4.2/gcc/config.gcc	2004-04-21 23:12:35.000000000 +0800
+++ ../gcc-3.4.2/gcc/config.gcc	2019-06-22 17:39:51.000000000 +0800
@@ -1321,6 +1321,25 @@
 		thread_file='posix'
 	fi
 	;;
+# Zylin ZPU
+zpu-*-*)
+    tm_file="dbxelf.h elfos.h zpu/zpu.h"
+    tm_p_file="zpu/zpu-protos.h"
+    md_file="zpu/zpu.md"
+    out_file="zpu/zpu.c"
+    extra_modes=zpu/zpu-modes.def
+    tmake_file="zpu/t-zpu-gas"
+    use_fixproto=yes
+        ;;
+logic32-*-*)
+    tm_file="dbxelf.h elfos.h logic32/logic32.h"
+    tm_p_file="logic32/logic32-protos.h"
+    md_file="logic32/logic32.md"
+    out_file="logic32/logic32.c"
+    extra_modes=logic32/logic32-modes.def
+    tmake_file="logic32/t-logic32-gas"
+    use_fixproto=yes
+        ;;
 # m68hc11 and m68hc12 share the same machine description.
 m68hc11-*-*|m6811-*-*)
 	tm_file="dbxelf.h elfos.h m68hc11/m68hc11.h"
