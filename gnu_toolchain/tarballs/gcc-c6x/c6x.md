;; Pattern definitions for the c6x target.
;;
;; Copyright (C) 2004 Jan Parthey
;;
;; This file is part of a TI TMS320 C6x target implementation for GCC, which
;; shall be called "GCC C6x target" for the purposes of this statement.
;;
;; "GCC C6x target" is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2 of the License, or
;; (at your option) any later version.
;;
;; "GCC C6x target" is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with "GCC C6x target"; if not, write to the Free Software
;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

;; TODO
;; - add support for the length attribute, see `HAVE_ATTR_' and
;;   `HAVE_ATTR_length'


;;;;
;; The `movM' pattern.  Mandatory on all machines.
;; - the pattern for SImode supports:
;;     - reg->reg by means of `mv src,dst'
;;     - mem->reg by means of `ld<x> src,dst'
;;     - reg->mem by means of `st<x> src,dst'
;;     - `scst16'->reg by means of `mvkl'
;;     - immediate->reg by means of `mvkl' and `mvkh'

(define_insn "movsi"
  [(set (match_operand:SI 0 "general_operand" "=r,r,m,r,r")
	(match_operand:SI 1 "general_operand" "r,m,r,M,i"))]
  ""
  "@
   mv %1, %0
   ldw %1, %0\;nop 4
   stw %1, %0
   mvkl %1, %0
   mvkl %1, %0\;mvkh %1, %0"
  [])

;; - `movM' for HImode
;;     - As opposed to movSI, this will only encounter `scst16' immediates, 
;;       hence only `M' constraint needs to be supported (`i' can be omitted).
;;     - When a constant >0x8000 is assigned to an _unsigned_ C-var such as
;;       "unsigned int hiModeVar __attribute__((mode (HI)));", it will
;;       nevertheless be handled as -32768 and will therefore satisfy the
;;       `M' constraint (see macro `CONST_OK_FOR_LETTER_P').
;;     - Note that writing `i' instead of `M' would be ok just as well,
;;       because:
;;         1. `fold_convert' has `force_fit_type' truncate large integer
;;            constants (reported by `unsigned_conversion_warning' in
;;            `convert_and_check').
;;         2. `immed_double_const', which is called by `expand_expr' for
;;            `INTEGER_CST' expressions, wraps unsigned constants with the
;;            MSB set to their signed equivalent, eg.: 65535 is wrapped to -1
;;            if mode is HImode.
(define_insn "movhi"
  [(set (match_operand:HI 0 "general_operand" "=r,r,m,r")
	(match_operand:HI 1 "general_operand" "r,m,r,M"))]
  ""
  "@
   mv %1, %0
   ldh %1, %0\;nop 4
   sth %1, %0
   mvkl %1, %0"
  [])

;; - `movM' for QImode
;;     - See "movhi" for why we may use constraint `M' or `i', here, rather than
;;       having to use a new constraint letter suitable specifically for QImode.
(define_insn "movqi"
  [(set (match_operand:QI 0 "general_operand" "=r,r,m,r")
	(match_operand:QI 1 "general_operand" "r,m,r,M"))]
  ""
  "@
   mv %1, %0
   ldb %1, %0\;nop 4
   stb %1, %0
   mvkl %1, %0"
  [])


;;;;
;; The `call' and `call_value' pattern.
;; - operand0: a (mem:function_mode ADDR), where ADDR is either a SYMBOL_REF or
;;             an address as prepared by `prepare_call_address' (simply a
;;             register, for example)
;; - the (const_int 0) is just there in order to satisfy the RTL format
;;   definition in rtl.def, which is "ee" for CALL and hence requires 2 args
;; - Any registers that occur within a CALL rtx are automatically considered
;;   as "used" (in terms of register allocation) by function `mark_used_regs'
;;   (see default case at bottom).  This is perfectly in line with what would
;;   happen to any rtx other than CALL.

(define_expand "call"
  [(match_operand 0 "" "")]
  ""
{
  c6x_expand_call (NULL_RTX, operands[0]);
  DONE;
}
)

(define_insn "*call_internal"
  [(call (mem (match_operand:SI 0 "c6x_call_operand" "r"))
         (const_int 0))]
  ""
  "b %0\;nop 5"
  [])


;; pattern for a call returning scalar (ie. non-`BLKmode') value
(define_expand "call_value"
  [(match_operand 0 "" "")
   (match_operand 1 "" "")]
  ""
{
  c6x_expand_call (operands[0], operands[1]);
  DONE;
}
)

(define_insn "*call_value_internal"
  [(set (match_operand:SI 0 "" "")
        (call (mem (match_operand:SI 1 "c6x_call_operand" "r"))
              (const_int 0)))]
  ""
  "b %1\;nop 5"
  [])

;;;;
;; The `prologue' pattern, which is to output the function prologue.
;;
;; Function `gen_prologue', which is generated by genemit.c, is called by
;; `thread_prologue_and_epilogue_insns', which is called after reload in
;; `rest_of_compilation'. See info gccint, node "Function Entry" for details.

(define_expand "prologue"
  [(const_int 1)]
  ""
{
  c6x_expand_prologue ();
  DONE;
})

;;;;
;; The `epilogue' pattern, which is to output the function epilogue.
;; Cf. the "prologue" pattern, above.

(define_expand "epilogue"
  [(const_int 0)]
  ""
{
  c6x_expand_epilogue (0);
  DONE;
})


;;;;
;; The `addM3' patterns.
;;
;; See pattern for `add_optab' in genopinit.c.  Function `init_optabs' passes
;; `PLUS' to `init_optab', which allocates a new `optab' for additions, which
;; is assigned to `add_optab' on return.  `init_optab' also makes
;; `code_to_optab [`PLUS']' point to the new optab, which is used by functions
;; like `expand_simple_binop' or `have_insn_for'.

;; The definition of "*addsi3_prologue" must come before "addsi3", because the
;; predicates of its operands constitute a special case.  It is used eg. in
;; `c6x_expand_prologue', `c6x_expand_epilogue', `c6x_emit_push',
;; `c6x_emit_pop'.
;;
;; The case with the 'L' constraint is essential, because otherwise the
;; jump_insn, which `c6x_expand_epilogue' emits for returning from a function,
;; will use `SCRATCH_REGNO' A14 twice in a conflicting way:  once via this
;; pattern, which matches for the rtx that `c6x_emit_pop' emits, and once
;; directly in `c6x_expand_epilogue' when using it for generating the
;; jump_insn.

(define_insn "*addsi3_prologue"
  [(set (match_operand:SI 0 "general_operand" "=r,r,r,r")
	(plus:SI (match_operand:SI 1 "general_operand" "%r,0,r,r")
		 (match_operand:SI 2 "const_int_operand" "L,M,M,i")))]
  ""
  "@
   add %2, %1, %0
   addk %2, %0
   mvkl %2, a14\;add %1, a14, %0
   mvkl %2, a14\;mvkh %2, a14\;add %1, a14, %0"
  [])


;; The addsi3 pattern is even used in tasks as simple as accessing local
;; variables on the stack, when GCC has to output code for computing the
;; offset to the base address of the local variables (`virtual_stack_vars_rtx').
;;
;; Eg. see: `expand_stmt' -> `genrtl_decl_stmt' -> `emit_local_var' ->
;; `expand_decl' -> `assign_temp' -> `assign_stack_temp_for_type' ->
;; `assign_stack_local' `assign_stack_local_1' -> `plus_constant' ->
;; `plus_constant_wide' -> `gen_rtx_PLUS'.
;;
;; If patterns for smaller integer modes are missing, GCC knows how to make up
;; for them by using patterns for wider modes. So we currently don't define
;; "addhi3" or "addqi3", since we don't need them at this stage.  See
;; `widen_operand' in `expand_binop', which is called by `expand_expr' at label
;; `binop2', for how this widening mechnism works.

(define_insn "addsi3"
  [(set (match_operand:SI 0 "general_operand" "=r")
	(plus:SI (match_operand:SI 1 "general_operand" "%r")
		 (match_operand:SI 2 "general_operand" "r")))]
  ""
  "add %1, %2, %0"
  [])

;;;;
;; The bit shifting pattern `ashlM3'
;;
;; Arithmetic-shift operand 1 left by a number of bits specified by operand 2,
;; and store the result in operand 0.

(define_insn "ashlsi3"
  [(set (match_operand:SI 0 "general_operand" "=r,r")
	(ashift:SI (match_operand:SI 1 "general_operand" "r,r")
		   (match_operand:SI 2 "general_operand" "r,J")))]
  ""
  ;; on c6x `shl <src2>, <src1>, <dst>' shifts <src2> by <src1> bits
  "@
   shl %1, %2, %0
   shl %1, %2, %0"
  [])

;; The bit shifting pattern `ashrM3'
;;
;; Arithmetic-shift operand 1 right by a number of bits specified by operand 2,
;; and store the result in operand 0, performing sign-extension.

(define_insn "ashrsi3"
  [(set (match_operand:SI 0 "general_operand" "=r,r")
	(ashiftrt:SI (match_operand:SI 1 "general_operand" "r,r")
		     (match_operand:SI 2 "general_operand" "r,J")))]
  ""
  ;; on c6x `shr <src2>, <src1>, <dst>' shifts <src2> by <src1> bits
  "@
   shr %1, %2, %0
   shr %1, %2, %0"
  [])

;; The bit shifting pattern `lshrM3'
;;
;; Logic-shift operand 1 right by a number of bits specified by operand 2,
;; and store the result in operand 0, performing zero-extension.

;; (define_insn "lshrsi3"
;;   [(set (match_operand:SI 0 "general_operand" "=r,r")
;; 	(lshiftrt:SI (match_operand:SI 1 "general_operand" "r,r")
;; 		     (match_operand:SI 2 "general_operand" "r,J")))]
;;   ""
;;   ;; on c6x `shru <src2>, <src1>, <dst>' shifts <src2> by <src1> bits
;;   "@
;;    shru %1, %2, %0
;;    shru %1, %2, %0"
;;   [])

(define_insn "lshrsi3"
  [(set (match_operand:SI 0 "general_operand" "=r")
	(lshiftrt:SI (match_operand:SI 1 "general_operand" "r ")
		     (match_operand:SI 2 "general_operand" "rJ")))]
  ""
  ;; on c6x `shru <src2>, <src1>, <dst>' shifts <src2> by <src1> bits
  "shru %1, %2, %0"
  [])



;;;;
;; The `cmpM' pattern gets passed only the operands, but no comparison operator.
;; So we just store op0 and op1 away and rely on some `bCOND' or the like to be
;; expanded immediately afterwards (which always happens according to info
;; gccint node "Standard Names", paragraph `bCOND') which creates both the RTL
;; for `cmpM' and for itself.
;;
;; The predicate function is obligatory.  It is called by `prepare_operand',
;; which is called from function `emit_cmp_and_jump_insn_1'.
(define_expand "cmpsi"
  [(match_operand:SI 0 "general_operand" "")
   (match_operand:SI 1 "general_operand" "")]
  ""
{
  c6x_compare_op0 = operands[0];
  c6x_compare_op1 = operands[1];
  DONE;
})

;;;; 
;; `tstM' pattern left undefined as suggested in [1] "Standard Names" for
;; machines that don't use (cc0)

;;;;
;; Basic conditional jump instructions.

;; bCOND pattern for "branch if not equal".  The RTL template is instantiated by
;; operand 0, which must be passed as parameter to the `gen_bne' function, and
;; operand 1, which is rtx for the comparison generated by `c6x_expand_compare'.
;;
;; `ia64.md' was taken as model for this define_expand.
;; See "*b_true" and "*b_false" for matching the rtx this expander definition
;; generates.  See "*cmp_*" for matching the insn that `c6x_expand_compare'
;; emits.
;;
;; Support for the `UNLT', `UNLE', `UNGT', `UNGE', and `UNEQ' codes is
;; optional -- see `do_jump' for how these codes are decomposed into an
;; `UNORDERED_EXPR' and a normal comparison.

(define_expand "bne"
  [(parallel [(set (pc)
	      (if_then_else (match_dup 1)
			    (label_ref (match_operand 0 "" ""))
			    (pc)))
	      (clobber (match_scratch:SI 2 "" ))])]
  ""
  "operands[1] = c6x_expand_compare (NE, VOIDmode);")

;; define_expand patterns for the remaining `bCOND' standard names, where
;; COND is every rtx_code in `GET_RTX_CLASS' `<'.  Search for `<' in `rtl.def'.
(define_expand "beq"
  [(parallel [(set (pc)
	      (if_then_else (match_dup 1)
			    (label_ref (match_operand 0 "" ""))
			    (pc)))
	      (clobber (match_scratch:SI 2 "" ))])]
  ""
  "operands[1] = c6x_expand_compare (EQ, VOIDmode);")

(define_expand "bge"
  [(parallel [(set (pc)
	      (if_then_else (match_dup 1)
			    (label_ref (match_operand 0 "" ""))
			    (pc)))
	      (clobber (match_scratch:SI 2 "" ))])]
  ""
  "operands[1] = c6x_expand_compare (GE, VOIDmode);")

(define_expand "bgt"
  [(parallel [(set (pc)
	      (if_then_else (match_dup 1)
			    (label_ref (match_operand 0 "" ""))
			    (pc)))
	      (clobber (match_scratch:SI 2 "" ))])]
  ""
  "operands[1] = c6x_expand_compare (GT, VOIDmode);")

(define_expand "ble"
  [(parallel [(set (pc)
	      (if_then_else (match_dup 1)
			    (label_ref (match_operand 0 "" ""))
			    (pc)))
	      (clobber (match_scratch:SI 2 "" ))])]
  ""
  "operands[1] = c6x_expand_compare (LE, VOIDmode);")

(define_expand "blt"
  [(parallel [(set (pc)
	      (if_then_else (match_dup 1)
			    (label_ref (match_operand 0 "" ""))
			    (pc)))
	      (clobber (match_scratch:SI 2 "" ))])]
  ""
  "operands[1] = c6x_expand_compare (LT, VOIDmode);")

(define_expand "bgeu"
  [(parallel [(set (pc)
	      (if_then_else (match_dup 1)
			    (label_ref (match_operand 0 "" ""))
			    (pc)))
	      (clobber (match_scratch:SI 2 "" ))])]
  ""
  "operands[1] = c6x_expand_compare (GEU, VOIDmode);")

(define_expand "bgtu"
  [(parallel [(set (pc)
	      (if_then_else (match_dup 1)
			    (label_ref (match_operand 0 "" ""))
			    (pc)))
	      (clobber (match_scratch:SI 2 "" ))])]
  ""
  "operands[1] = c6x_expand_compare (GTU, VOIDmode);")

(define_expand "bleu"
  [(parallel [(set (pc)
	      (if_then_else (match_dup 1)
			    (label_ref (match_operand 0 "" ""))
			    (pc)))
	      (clobber (match_scratch:SI 2 "" ))])]
  ""
  "operands[1] = c6x_expand_compare (LEU, VOIDmode);")

(define_expand "bltu"
  [(parallel [(set (pc)
	      (if_then_else (match_dup 1)
			    (label_ref (match_operand 0 "" ""))
			    (pc)))
	      (clobber (match_scratch:SI 2 "" ))])]
  ""
  "operands[1] = c6x_expand_compare (LTU, VOIDmode);")

;; TODO: ordered/unordered floating point comparisons
;; (define_expand "bordered" 
;; (define_expand "bunordered" 


;; Recognize conditional branches as generated by "beq" and siblings.
;;
;; Op0: reloaded to a register of class CONDITION_A_REGS or CONDITION_B_REGS
;; Op1: a CODE_LABEL as generated by `gen_label_rtx'
;; Op2: We need a scratch register to be used as the target of the jump. We
;;      use alternatives in order to get only regs from either A or B side.
;;
;; Note: the output template doesn't start with 

(define_insn "*b_true"
  [(set (pc)
	(if_then_else (ne:BI (match_operand:BI 0 "general_operand" "B,A") 
	                     (const_int 0))
		      (label_ref (match_operand 1 "" ""))
		      (pc)))
   (clobber (match_scratch:SI 2 "=&b,a"))]
  ""
  "@
   [%0] mvkl .S2 %1, %2 \;[%0] mvkh .S2 %1, %2 \;[%0] b .S2 %2 \;nop 5
   [%0] mvkl .S1 %1, %2 \;[%0] mvkh .S1 %1, %2 \;[%0] b .S1 %2 \;nop 5"
  [])

;; Analogous to "*b_true", but with the condition reversed.
;; `c6x_expand_compare' emits this in order to work around the lacking `CMPGE',
;; `CMPLT', `CMPGEU', and `CMPLEU' on c6x.
(define_insn "*b_false"
  [(set (pc)
	(if_then_else (eq:BI (match_operand:BI 0 "general_operand" "B,A") 
	                     (const_int 0))
		      (label_ref (match_operand 1 "" ""))
		      (pc)))
   (clobber (match_scratch:SI 2 "=&b,a"))]
  ""
  "@
   [!%0] mvkl .S2 %1, %2 \;[!%0] mvkh .S2 %1, %2 \;[!%0] b .S2 %2 \;nop 5
   [!%0] mvkl .S1 %1, %2 \;[!%0] mvkh .S1 %1, %2 \;[!%0] b .S1 %2 \;nop 5"
  [])

;; Recognize the insn emitted by `c6x_expand_compare' for storing the result
;; of a comparison into a register (preferably a predicate register, but this
;; is not specified here, since "class preferencing" will hopefully notice
;; that the same pseudo has a "B,A" constraint in the "*b_true" pattern, above,
;; and hence will provide a predicate register for the target operand).

;; Patterns for `eq', `gt', `lt', `gtu', and `ltu'
;; There are no mnemonics for `ne', `ge', `le', `geu', `leu' on c6x, but we
;; handle them by letting `c6x_expand_compare' expand the reversed condition
;; and rtx for the "*b_false" pattern, eg. `ge' is provided by emitting `lt'
;; and an `(set (pc) (if_then_else (eq ...' rather than `... (ne ...'
;; TODO: use `match_operator' instead of 5 seperate insn patterns
(define_insn "*cmp_eq"
  [(set (match_operand:BI 0 "general_operand" "=b,=a")
        (eq:BI (match_operand:SI 1 "general_operand" "b,a")
	       (match_operand:SI 2 "general_operand" "b,a")))
  ]
  ""
  "@
   cmpeq .L2 %1, %2, %0
   cmpeq .L1 %1, %2, %0"
  [])
(define_insn "*cmp_gt"
  [(set (match_operand:BI 0 "general_operand" "=b,=a")
        (gt:BI (match_operand:SI 1 "general_operand" "b,a")
	       (match_operand:SI 2 "general_operand" "b,a")))
  ]
  ""
  "@
   cmpgt .L2 %1, %2, %0
   cmpgt .L1 %1, %2, %0"
  [])
(define_insn "*cmp_lt"
  [(set (match_operand:BI 0 "general_operand" "=b,=a")
        (lt:BI (match_operand:SI 1 "general_operand" "b,a")
	       (match_operand:SI 2 "general_operand" "b,a")))
  ]
  ""
  "@
   cmplt .L2 %1, %2, %0
   cmplt .L1 %1, %2, %0"
  [])
(define_insn "*cmp_gtu"
  [(set (match_operand:BI 0 "general_operand" "=b,=a")
        (gtu:BI (match_operand:SI 1 "general_operand" "b,a")
	        (match_operand:SI 2 "general_operand" "b,a")))
  ]
  ""
  "@
   cmpgtu .L2 %1, %2, %0
   cmpgtu .L1 %1, %2, %0"
  [])
(define_insn "*cmp_ltu"
  [(set (match_operand:BI 0 "general_operand" "=b,=a")
        (ltu:BI (match_operand:SI 1 "general_operand" "b,a")
	        (match_operand:SI 2 "general_operand" "b,a")))
  ]
  ""
  "@
   cmpltu .L2 %1, %2, %0
   cmpltu .L1 %1, %2, %0"
  [])

;;;;
;; The unconditional jump instruction with a label as target. Mandatory on all
;; machines.  
;;     - Operand 0 is expected to be a `CODE_LABEL'.  See `output_asm_label'
;;       for how the `l' modifier in %l0 is handled.
;;     - FIXME: Note that `CODE_LABEL' can in principle point to code locations
;;       that require a larger displacement than can be specified by the 21
;;       (left-shifted by 2) bits with mnemonic `b' ("Branch Using a
;;       Displacement").  So I tried the following, which made gcc exit with
;;       error "mainvirtual memory exhausted: Cannot allocate memory" for
;;       some reason:
;;         - (define_insn "jump"
;;             [(set (pc) (label_ref (match_operand 0 "" "")))
;;              (clobber (match_scratch:SI 1 "=&b,a"))]
;;             ""
;;             "@
;;              mvkl .S2 %l0, %1 \;mvkh .S2 %l0, %1 \;b .S2 %1 \;nop 5
;;              mvkl .S1 %l0, %1 \;mvkh .S1 %l0, %1 \;b .S1 %1 \;nop 5"
;;             [])
;;         - So, for now, just output the label, which produces invalid asm
;;           code in the case of very large jumps.

;; (define_insn "jump"
;;   [(set (pc) (label_ref (match_operand 0 "" "")))
;;    (clobber (match_scratch:SI 1 "r"))]
;;   ""
;;   "mvkl .S2 %0, %1 \; mvkh .S2 %0, %1 \; b .S2 %1 \;nop 5"
;;   ;;"b %l0 \;nop 5"
;;   [])
(define_insn "jump"
  [(set (pc) (label_ref (match_operand 0 "" "")))]
  ""
  "b %l0 \;nop 5"
  [])



;;;;
;; The unconditional jump instruction with a register as target. Mandatory on
;; all machines.  Only .S2 can handle indirect jumps, so discourage A regs,
;; which would use a cross path. 
(define_insn "indirect_jump"
  [(set (pc) (match_operand:SI 0 "general_operand" "b,?a"))]
  ""
  "@
   b .S2 %0 \;nop 5
   b .S2 %0 \;nop 5"
  [])

;;;;
;; The "tablejump" pattern for `switch' statements.
;;   - see node `Standard Names'
;;   - If CASE_VALUES_THRESHOLD is exceeded by the number of alternatives in
;;     any `switch' statement, `expand_end_case_type' requires either
;;     `try_casesi' (pattern "casesi") or `try_tablejump' (pattern "tablejump")
;;     to succeed.
;;   - both alternatives use .S2, because .S1 cannot handle this type of jump

(define_insn "tablejump"
  [(set (pc) (match_operand:SI 0 "general_operand" "b,?a"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
  "@
   b .S2 %0 \;nop 5
   b .S2 %0 \;nop 5"
  [])


;;;;
;; `nop' instruction. Mandatory on all machines.
(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [])

